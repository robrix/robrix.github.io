---
measure: measure-wide
title:  "Duality"
date:   2021-06-07 19:49:02
categories: logic, plt
---

The rules for a variety of polarized classical connectives, in a focused sequent calculus presentation to reflect a variety of dualities, and interpreted via Curry-Howard.

<!--more-->

<script src="https://polyfill.io/v3/polyfill.min.js?features=es6"></script>
<script type="text/javascript" id="MathJax-script" async src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-svg.js"></script>

<script type="text/x-mathjax-config">
MathJax.Hub.Config({
  tex2jax: { inlineMath: [["$","$"],["\\(","\\)"]] },
  "HTML-CSS": { linebreaks: { automatic: true } },
  "SVG":      { linebreaks: { automatic: true } }
});
</script>

<style type="text/css">
td.absent {
  text-align: center;
}
td p {
  line-height: 1.2;
}
</style>

$$
\require{bussproofs}
$$

<table class="borderless">
  <colgroup>
    <col span="2">
    <col span="2">
  </colgroup>
  <tbody>
    <tr>
      <th colspan="4"><a name="additive">Additive</a></th>
    </tr>
    <tr>
      <td colspan="2">
        <div class="connective">
          <div class="column">
            <div class="rule">
              <div class="label">&amp;⊢<sub>1</sub></div>
              <div class="inference">
                <div class="premise Γ">[A<sup>−</sup>] Γ</div>
                <div class="premise turnstile">⊢</div>
                <div class="premise Δ">Δ</div>
                <span class="line-of-inference"></span>
                <div class="conclusion Γ">[A<sup>−</sup> &amp; B<sup>−</sup>] Γ</div>
                <div class="conclusion turnstile">⊢</div>
                <div class="conclusion Δ">Δ</div>
              </div>
            </div>
            <div class="rule">
              <div class="label">&amp;⊢<sub>2</sub></div>
              <div class="inference">
                <div class="premise Γ">[B<sup>−</sup>] Γ</div>
                <div class="premise turnstile">⊢</div>
                <div class="premise Δ">Δ</div>
                <span class="line-of-inference"></span>
                <div class="conclusion Γ">[A<sup>−</sup> &amp; B<sup>−</sup>] Γ</div>
                <div class="conclusion turnstile">⊢</div>
                <div class="conclusion Δ">Δ</div>
              </div>
            </div>
          </div>
          <div class="rule">
            <div class="inference">
              <div class="premises">
                <div class="premise">Γ ⊢ Δ, A<sup>−</sup></div>
                <div class="premise">Γ ⊢ Δ, B<sup>−</sup></div>
              </div>
              <span class="line-of-inference"></span>
              <div class="conclusion">Γ ⊢ Δ, A<sup>−</sup> &amp; B<sup>−</sup></div>
            </div>
            <div class="label">⊢&amp;</div>
          </div>
        </div>
      </td>
      <td colspan="2" rowspan="5">
        <p>The additive connectives, &amp; (pronounced “with”) and ⊕ (“sum”) are unfamiliar symbols for familiar connectives: &amp; is conjunction (∧, “and”), while ⊕ is disjunction (∨, “or”).</p>
        <p>&amp; is negative, and thus focused on the left (indicated by the square brackets). In a polarized calculus, negative connectives are defined by their left rules, which are rules for how to use them. (Γ contains inputs, so left rules consume things.) &amp; has two left rules, which use it by projecting out the left and right parts, respectively. Its right rule builds it from its components: think pair/tuple literals.</p>
        <p>⊕ is positive, and thus focused on the right. Positive connectives are defined by their right rules, which are rules for how to make them. (Δ contains outputs, so right rules produce things.) Its left rule consumes the sum by handling each alternative separately; think <code>case</code> expressions over an <code>Either</code>.</p>
      </td>
    </tr>
    <tr>
      <td colspan="2" class="caption">
        &amp; (“with”): negative conjunction ≈ lazy pair
      </td>
    </tr>
    <tr>
      <td colspan="2">
        <div class="connective">
          <div class="rule">
            <div class="label">⊕⊢</div>
            <div class="inference">
              <div class="premises">
                <div class="premise">A<sup>+</sup>, Γ ⊢ Δ</div>
                <div class="premise">B<sup>+</sup>, Γ ⊢ Δ</div>
              </div>
              <span class="line-of-inference"></span>
              <div class="conclusion">A<sup>+</sup> ⊕ B<sup>+</sup>, Γ ⊢ Δ</div>
            </div>
          </div>
          <div class="column">
            <div class="rule">
              <div class="inference">
                <div class="premise Γ">Γ</div>
                <div class="premise turnstile">⊢</div>
                <div class="premise Δ">Δ [A<sup>+</sup>]</div>
                <span class="line-of-inference"></span>
                <div class="conclusion Γ">Γ</div>
                <div class="conclusion turnstile">⊢</div>
                <div class="conclusion Δ">Δ [A<sup>+</sup> ⊕ B<sup>+</sup>]</div>
              </div>
              <div class="label">⊢⊕<sub>1</sub></div>
            </div>
            <div class="rule">
              <div class="inference">
                <div class="premise Γ">Γ</div>
                <div class="premise turnstile">⊢</div>
                <div class="premise Δ">Δ [B<sup>+</sup>]</div>
                <span class="line-of-inference"></span>
                <div class="conclusion Γ">Γ</div>
                <div class="conclusion turnstile">⊢</div>
                <div class="conclusion Δ">Δ [A<sup>+</sup> ⊕ B<sup>+</sup>]</div>
              </div>
              <div class="label">⊢⊕<sub>2</sub></div>
            </div>
          </div>
        </div>
      </td>
    </tr>
    <tr>
      <td colspan="2" class="caption">
        ⊕ (“sum”): positive disjunction ≈ either
      </td>
    </tr>
    <tr>
      <td colspan="2">
        <div class="connective">
          <div class="rule">
            <p>~(A<sup>−</sup> &amp; B<sup>−</sup>) ≈ ~A<sup>−</sup> ⊕ ~B<sup>−</sup></p>
          </div>
          <div class="rule">
            <p>¬(A<sup>+</sup> ⊕ B<sup>+</sup>) ≈ ~A<sup>+</sup> &amp; ~B<sup>+</sup></p>
          </div>
        </div>
      </td>
    </tr>
    <tr>
      <td colspan="2" rowspan="5">
        <p>The additive units, ⊤ (“top”) and 0, are a bit of a puzzle. Note that neither has a focusing rule: you can’t use a ⊤ once you have it, and you can’t get a 0 at all. On the other hand, both their invertible rules are axioms (i.e. have no premises).</p>
        <p>A sequent Γ ⊢ Δ can be read as “all of Γ prove any of Δ;” under that interpretation we can see that ⊤, which corresponds to logical truth, indeed satisfies that claim: once at least one thing on the right is proven, we’re done.</p>
        <p>Likewise, the left rule for 0, falsity, is recognizable as the principle of <em>ex falso quodlibet</em>: you can prove anything at all from a contradiction.</p>
      </td>
      <td colspan="2">
        <div class="connective">
          <div class="rule">
            <p>no rule for ⊤⊢</p>
          </div>
          <div class="rule">
            <div class="inference">
              <div class="axiom"></div>
              <span class="line-of-inference"></span>
              <div class="conclusion">Γ ⊢ Δ, ⊤</div>
            </div>
            <div class="label">⊢⊤</div>
          </div>
        </div>
      </td>
    </tr>
    <tr>
      <td colspan="2" class="caption">
        ⊤ (“top”): negative truth ≈ unit
      </td>
    </tr>
    <tr>
      <td colspan="2">
        <div class="connective">
          <div class="rule">
            <div class="label">0⊢</div>
            <div class="inference">
              <div class="axiom"></div>
              <span class="line-of-inference"></span>
              <div class="conclusion">0, Γ ⊢ Δ</div>
            </div>
          </div>
          <div class="rule">
            <p>no rule for ⊢0</p>
          </div>
        </div>
      </td>
    </tr>
    <tr>
      <td colspan="2" class="caption">
        0: positive falsity ≈ void
      </td>
    </tr>
    <tr>
      <td colspan="2">
        $$
        \sim \kern -1pt ⊤ ≈ 0 \hskip 1.5em ¬0 ≈ ⊤
        $$
      </td>
    </tr>
    <tr>
      <th colspan="4"><a name="multiplicative">Multiplicative</a></th>
    </tr>
    <tr>
      <td colspan="2">
        <div class="connective">
          <div class="rule">
            <div class="label">⅋⊢</div>
            <div class="inference">
              <div class="premises">
                <div class="premise">[A<sup>−</sup>] Γ ⊢ Δ</div>
                <div class="premise">[B<sup>−</sup>] Γ ⊢ Δ</div>
              </div>
              <span class="line-of-inference"></span>
              <div class="conclusion">[A<sup>−</sup> ⅋ B<sup>−</sup>] Γ ⊢ Δ</div>
            </div>
          </div>
          <div class="rule">
            <div class="inference">
              <div class="premise Γ">Γ</div>
              <div class="premise turnstile">⊢</div>
              <div class="premise Δ">Δ, A<sup>−</sup>, B<sup>−</sup></div>
              <span class="line-of-inference"></span>
              <div class="conclusion Γ">Γ</div>
              <div class="conclusion turnstile">⊢</div>
              <div class="conclusion Δ">Δ, A<sup>−</sup> ⅋ B<sup>−</sup></div>
            </div>
            <div class="label">⊢⅋</div>
          </div>
        </div>
      </td>
      <td colspan="2" rowspan="5">
        <p>In addition to &amp; and ⊕, the <em>additive</em> conjunction and disjunction, ⅋ (“par”) and ⊗ (“tensor”) are <em>multiplicative</em> disjunction and conjunction. The difference is more obvious in a linear logic, but for us the relevant distinction between &amp; and ⊗ is that we identify negative (resp. positive) types like &amp; (resp. ⊗) with call-by-name (resp. call-by-value).</p>
        <p>⅋, however, is stranger. It’s a disjunction, eliminated by using both halves (just like ⊕), but introduced using <em>two</em> things. Linear logic again offers one perspective, but another reading of Γ ⊢ Δ (via Curry-Howard) as “consume Γ to produce Δ” is salient: parallelism (hence “par”), or nondeterminism. The latter explains why ⅋ is disjunctive despite (at least notionally) containing two things; think of <code>&lt;|&gt;</code>. For <code>Maybe</code>, it selects the leftmost <code>Just</code>, acting as a choice; for <code>[]</code>, it instead selects <em>all</em> alternatives, acting as a union.</p>
      </td>
    </tr>
    <tr>
      <td colspan="2" class="caption">
        ⅋ (“par”): negative disjunction ≈ parallel/nondeterministic choice
      </td>
    </tr>
    <tr>
      <td colspan="2">
        <div class="connective">
          <div class="rule">
            <div class="label">⊗⊢</div>
            <div class="inference">
              <div class="premise Γ">A<sup>+</sup>, B<sup>+</sup>, Γ</div>
              <div class="premise turnstile">⊢</div>
              <div class="premise Δ">Δ</div>
              <span class="line-of-inference"></span>
              <div class="conclusion Γ">A<sup>+</sup> ⊗ B<sup>+</sup>, Γ</div>
              <div class="conclusion turnstile">⊢</div>
              <div class="conclusion Δ">Δ</div>
            </div>
          </div>
          <div class="rule">
            <div class="inference">
              <div class="premises">
                <div class="premise">Γ ⊢ Δ [A<sup>+</sup>]</div>
                <div class="premise">Γ ⊢ Δ [B<sup>+</sup>]</div>
              </div>
              <span class="line-of-inference"></span>
              <div class="conclusion">Γ ⊢ Δ [A<sup>+</sup> ⊗ B<sup>+</sup>]</div>
            </div>
            <div class="label">⊢⊗</div>
          </div>
        </div>
      </td>
    </tr>
    <tr>
      <td colspan="2" class="caption">
        ⊗ (“tensor”): positive conjunction ≈ strict pair
      </td>
    </tr>
    <tr>
      <td colspan="2">
        $$
        \sim \kern -3pt (A^- ⅋\ \ \ B^-) ≈\kern 3pt \sim \kern -3pt A^- ⊗ \sim \kern -3pt B^- \hskip 1.5em ¬(A^+ ⊗ B^+) ≈ ¬A^+ ⅋\ \ \ ¬B^+
        $$
      </td>
    </tr>
    <tr>
      <td colspan="2" rowspan="5">
        <p>Alongside multiplicative disjunction and conjunction are ⊥ (“bottom”), a negative falsity, and 1, a positive truth.</p>
        <p>⊥, like positive falsity (0), proves anything if you’ve already got one (⊥⊢). Surprisingly, we can introduce one when we can prove the rest of the sequent (⊢⊥). Logically, falsity can’t change Δ’s provability, so this rule is justified.</p>
        <p>Dually, we can’t learn anything from vacuous truth, so 1 can be eliminated freely (1⊢). Introducing it is likewise trivial (⊢1), just as for ⊤.</p>
      </td>
      <td colspan="2">
        $$
        \begin{prooftree}
        \hskip -10pt
        \def\labelSpacing{8pt}
        \LeftLabel{$⊥ \kern1pt ⊢$}
        \AxiomC{}
        \UnaryInfC{$[⊥] Γ ⊢ Δ$}
        \end{prooftree}
        \begin{prooftree}
        \hskip 10pt
        \def\labelSpacing{8pt}
        \RightLabel{$\ ⊢ \kern1pt ⊥$}
        \Axiom$\fCenter Γ ⊢ Δ$
        \UnaryInf$\fCenter Γ ⊢ Δ, ⊥$
        \end{prooftree}
        $$
      </td>
    </tr>
    <tr>
      <td colspan="2" class="caption">
        ⊥ (“bottom”): negative falsity ≈ void
      </td>
    </tr>
    <tr>
      <td colspan="2">
        $$
        \begin{prooftree}
        \hskip -10pt
        \def\labelSpacing{8pt}
        \LeftLabel{$1 \kern1pt ⊢$}
        \Axiom$\fCenter Γ ⊢ Δ$
        \UnaryInf$1, \fCenter Γ ⊢ Δ$
        \end{prooftree}
        \begin{prooftree}
        \hskip 10pt
        \def\labelSpacing{8pt}
        \RightLabel{$\ ⊢ \kern1pt 1$}
        \AxiomC{}
        \UnaryInfC{$Γ ⊢ Δ [1]$}
        \end{prooftree}
        $$
      </td>
    </tr>
    <tr>
      <td colspan="2" class="caption">
        1: positive truth ≈ unit
      </td>
    </tr>
    <tr>
      <td colspan="2">
        $$
        \sim \kern -1pt ⊥ ≈ 1 \hskip 1.5em ¬1 ≈ ⊥
        $$
      </td>
    </tr>
    <tr>
      <th colspan="4"><a name="implicative">Implicative</a></th>
    </tr>
    <tr>
      <td colspan="2">
        $$
        \begin{prooftree}
        \hskip -10pt
        \def\labelSpacing{8pt}
        \LeftLabel{$→ \kern1pt ⊢$}
        \AxiomC{$\fCenter Γ ⊢ Δ [A^+]$}
        \AxiomC{$[B^-] \fCenter Γ ⊢ Δ$}
        \BinaryInfC{$[A^+ → B^-] \fCenter Γ ⊢ Δ$}
        \end{prooftree}
        \begin{prooftree}
        \hskip 10pt
        \def\labelSpacing{8pt}
        \RightLabel{$\ ⊢ \kern1pt →$}
        \Axiom$A^+, \fCenter Γ ⊢ Δ, B^-$
        \UnaryInf$\fCenter Γ ⊢ Δ, A^+ → B^-$
        \end{prooftree}
        $$
      </td>
      <td colspan="2" rowspan="5">
        <p>Just as implication resembles the turnstile (as is evident in the premise of ⊢→), our computational reading of Γ ⊢ Δ as “consume Γ to produce Δ” indicates that functions do as well.</p>
        <p>A – B can be read as “A without B” (both arithmetically and logically), but insight into its computational interpretation can be gained by its relationship to functions.</p>
        <p>The premises for →⊢ and ⊢– are the same, as are the ones for ⊢→ and –⊢: duality <em>means</em> “each eliminates the other.” → eliminations are function calls, so – has an argument: the A in the first premise of ⊢–. B is a hypothesis, meaning that the derivation must <em>provide</em> it. Therefore, it also has a <em>continuation from B</em>—and thus, everything you need to call a function: both input, and output destination.</p>
        <p>This gives a vivid picture of the nature of duality: a subtraction is the negative space around an implication, and an implication is therefore also the negative space around a subtraction. A complete view of either requires both.</p>
      </td>
    </tr>
    <tr>
      <td colspan="2" class="caption">
        →: negative implication ≈ function
      </td>
    </tr>
    <tr>
      <td colspan="2">
        $$
        \begin{prooftree}
        \hskip -10pt
        \def\labelSpacing{8pt}
        \LeftLabel{$- \kern1pt ⊢$}
        \Axiom$A^+, \fCenter Γ ⊢ Δ, B^-$
        \UnaryInf$A^+ - B^-, \fCenter Γ ⊢ Δ$
        \end{prooftree}
        \begin{prooftree}
        \hskip 10pt
        \def\labelSpacing{8pt}
        \RightLabel{$\ ⊢ \kern1pt -$}
        \AxiomC{$\fCenter Γ ⊢ Δ [A^+]$}
        \AxiomC{$[B^-] \fCenter Γ ⊢ Δ$}
        \BinaryInfC{$\fCenter Γ ⊢ Δ [A^+ - B^-]$}
        \end{prooftree}
        $$
      </td>
    </tr>
    <tr>
      <td colspan="2" class="caption">
        – (“subtraction”, sometimes ⤙, “co-implication”): positive implication ≈ calling context
      </td>
    </tr>
    <tr>
      <td colspan="2">
        $$
        \sim \kern -3pt (A^+ → B^-) ≈ A^+ - B^- \hskip 1.5em ¬(A^+ - B^-) ≈ A^+ → B^-
        $$
      </td>
    </tr>
    <tr>
      <th colspan="4"><a name="negating">Negating</a></th>
    </tr>
    <tr>
      <td colspan="2" rowspan="5">
        <p>Like → and –, negations have the interesting behaviour of moving propositions across the turnstile: from antecedents to succeedents. They are constructed (⊢¬ and ⊢~) from a premise with a hypothesis: to make a ¬A or ~A, we must have a premise which uses an A—rather like the premise of ⊢→. Dually, their elimination (¬⊢ and ~⊢) requires an A to use as input. Thus, negations have long been given computational meaning as <em>continuations</em>, a representation of “the rest of the program” from some program point.</p>
        <p>Intuitionistic logics therefore often encode negation as implication of falsity, i.e. ¬A ≈ A → ⊥. Intuitively, “not A” and “A implies falsity” align. This has the precise shape of a continuation. Further, double-negation like ¬¬A becomes (A → ⊥) → ⊥, which has the shape of continuation-passing style.</p>
        <p>Our negations are <em>involutive</em>, i.e. (mutual) self-inverses, due both to polarization (flipped from their argument) and focusing behaviour (remaining in the current phase).</p>
      </td>
      <td colspan="2">
        $$
        \begin{prooftree}
        \hskip -10pt
        \def\labelSpacing{8pt}
        \LeftLabel{$¬ \kern1pt ⊢$}
        \Axiom$\fCenter Γ ⊢ Δ [A^+]$
        \UnaryInf$[¬A^+] \fCenter Γ ⊢ Δ$
        \end{prooftree}
        \begin{prooftree}
        \hskip 10pt
        \def\labelSpacing{8pt}
        \RightLabel{$\ ⊢ \kern1pt ¬$}
        \Axiom$A^+, \fCenter Γ ⊢ Δ$
        \UnaryInf$\fCenter Γ ⊢ Δ, ¬A^+$
        \end{prooftree}
        $$
      </td>
    </tr>
    <tr>
      <td colspan="2" class="caption">
        ¬ (“not”): positive-within-negative negation ≈ lazy continuation
      </td>
    </tr>
    <tr>
      <td colspan="2">
        $$
        \begin{prooftree}
        \hskip -10pt
        \def\labelSpacing{8pt}
        \LeftLabel{$\sim \kern1pt ⊢$}
        \Axiom$\fCenter Γ ⊢ Δ, A^-$
        \UnaryInf$\sim\kern -3pt A^-, \fCenter Γ ⊢ Δ$
        \end{prooftree}
        \begin{prooftree}
        \hskip 10pt
        \def\labelSpacing{8pt}
        \RightLabel{$\ ⊢ \kern1pt \sim$}
        \Axiom$[A^-] \fCenter Γ ⊢ Δ$
        \UnaryInf$\fCenter Γ ⊢ Δ [\sim\kern -3pt A^-]$
        \end{prooftree}
        $$
      </td>
    </tr>
    <tr>
      <td colspan="2" class="caption">
        ~ (“negate”): negative-within-positive negation ≈ strict continuation
      </td>
    </tr>
    <tr>
      <td colspan="2">
        $$
        \sim \kern -3pt ¬A^+ ≈ A^+ \hskip 1.5em ¬\sim \kern -3pt A^- ≈ A^-
        $$
      </td>
    </tr>
    <tr>
      <th colspan="4"><a name="shifts">Shifts</a></th>
    </tr>
    <tr>
      <td colspan="2">
        $$
        \begin{prooftree}
        \hskip -10pt
        \def\labelSpacing{8pt}
        \LeftLabel{$↑ \kern1pt ⊢$}
        \Axiom$A^+, \fCenter Γ ⊢ Δ$
        \UnaryInf$[↑A^+] \fCenter Γ ⊢ Δ$
        \end{prooftree}
        \begin{prooftree}
        \hskip 10pt
        \def\labelSpacing{8pt}
        \RightLabel{$\ ⊢ \kern1pt ↑$}
        \Axiom$\fCenter Γ ⊢ Δ, A^+$
        \UnaryInf$\fCenter Γ ⊢ Δ, ↑A^+$
        \end{prooftree}
        $$
      </td>
      <td colspan="2" rowspan="6">
        <p>Shifts serve two pragmatic purposes: like negations, they have the opposite polarity of whatever they shift; and they end the focusing phase of proof search and begin the inversion phase.</p>
        <p>Up shifts may be unfamiliar in terms of types, but at the term level are something like a <code>return</code>, particularly in monadic code: they embed a value (positive) within a computation (negative). In CBPV (call-by-push-value), this is the left adjoint, F.</p>
        <p>Down shifts, meanwhile, may be more familiar as thunks: they wrap a computation (negative) up into a value (positive). In CBPV, this is the right adjoint, U.</p>
        <p>The translations of function types from CBN and CBV into polarized calculi (left) model evaluation orders using shifts. The CBN translation treats arguments as thunks around lazy computations, while the CBV translation explicitly wraps the result in a computation.</p>
      </td>
    </tr>
    <tr>
      <td colspan="2" class="caption">
        ↑ (“up shift,” call-by-push-value’s <em>F</em>): positive-within-negative shift ≈ return
      </td>
    </tr>
    <tr>
      <td colspan="2">
        $$
        \begin{prooftree}
        \hskip -10pt
        \def\labelSpacing{8pt}
        \LeftLabel{$↓ \kern1pt ⊢$}
        \Axiom$A^-, \fCenter Γ ⊢ Δ$
        \UnaryInf$↓A^-, \fCenter Γ ⊢ Δ$
        \end{prooftree}
        \begin{prooftree}
        \hskip 10pt
        \def\labelSpacing{8pt}
        \RightLabel{$\ ⊢ \kern1pt ↓$}
        \Axiom$\fCenter Γ ⊢ Δ, A^-$
        \UnaryInf$\fCenter Γ ⊢ Δ [↓A^-]$
        \end{prooftree}
        $$
      </td>
    </tr>
    <tr>
      <td colspan="2" class="caption">
        ↓ (“down shift”, call-by-push-value’s <em>U</em>): negative-within-positive shift ≈ thunk
      </td>
    </tr>
    <tr>
      <td colspan="2">
      $$
      \hskip 0em (A → B)^N\ =\ ↓(A^N) → B
      $$
      $$
      \hskip 0em (A → B)^V\ =\ ↓(A^V →\kern 3pt ↑(B^V))
      $$
      </td>
    </tr>
    <tr>
      <td colspan="2" class="caption">
        translations of CBN and CBV function types into polarized calculi
      </td>
    </tr>
    <tr>
      <th colspan="4"><a name="shifts">Quantifiers</a></th>
    </tr>
    <tr>
      <td colspan="2" rowspan="5">
        <p>The rules for quantification are slightly unusual in this presentation in their use of both side conditions (checking that the variable does not occur free elsewhere within the sequent) and (capture-avoiding) substitution (A{B/X} substitutes the proposition B for the variable X within A, e.g. (X ⊕ Y){Z/X} = Z ⊕ Y).</p>
        <p>Quantified propositions—and thus, types—offer yet more dualities: both can be used to hide information, but from different perspectives. ∀ constrains its construction, but is used freely; ∃ constrains its uses, but is constructed freely. Universally-quantified types are used when folding polymorphically recursive data and a variety of encodings using functions. Existentials model abstraction in abstract data types, ML modules, open universes of exceptions, and GADTs.</p>
        <p>Here, the identification of negative = computation, positive = value is stretched. If computation in the CBPV sense is “something resident in code pages” then ∀ seems misplaced—why should ∀ be represented at runtime (absent dependent types)? On the other hand, the identification of positive = data, negative = codata fits: ∀ is defined by how it is used, and ∃ by how it is made.</p>
      </td>
      <td colspan="2">
        $$
        \begin{prooftree}
        \hskip -10pt
        \def\labelSpacing{8pt}
        \LeftLabel{$∀ \kern1pt ⊢$}
        \Axiom$[A^-\{B/X\}] \fCenter Γ ⊢ Δ$
        \UnaryInf$[∀X.A^-] \fCenter Γ ⊢ Δ$
        \end{prooftree}
        \begin{prooftree}
        \hskip 10pt
        \def\labelSpacing{8pt}
        \RightLabel{$\ ⊢ ∀$}
        \Axiom$\fCenter Γ ⊢ Δ, A^- \hskip 1.5em X ∉ fv(Γ ⊢ Δ)$
        \UnaryInf$\fCenter Γ ⊢ Δ, ∀X.A^-$
        \end{prooftree}
        $$
      </td>
    </tr>
    <tr>
      <td colspan="2" class="caption">
        ∀ (“for all”): universal quantification ≈ polymorphism
      </td>
    </tr>
    <tr>
      <td colspan="2">
        $$
        \begin{prooftree}
        \hskip -10pt
        \def\labelSpacing{8pt}
        \LeftLabel{$∃ \kern1pt ⊢$}
        \Axiom$X ∉ fv(Γ ⊢ Δ) \hskip 1.5em A^+, \fCenter Γ ⊢ Δ$
        \UnaryInf$∃X.A^+, \fCenter Γ ⊢ Δ$
        \end{prooftree}
        \begin{prooftree}
        \hskip 10pt
        \def\labelSpacing{8pt}
        \RightLabel{$\ ⊢ \kern1pt ∃$}
        \Axiom$\fCenter Γ ⊢ Δ [A^+\{B/X\}]$
        \UnaryInf$\fCenter Γ ⊢ Δ [∃X.A^+]$
        \end{prooftree}
        $$
      </td>
    </tr>
    <tr>
      <td colspan="2" class="caption">
        ∃ (“there exists”): existential quantification ≈ abstract data type
      </td>
    </tr>
    <tr>
      <td colspan="2">
        $$
        \sim \kern -3pt (∀X.A^-) ≈ ∃X.\sim \kern -3pt A^- \hskip 1.5em ¬(∃X.A^+) ≈ ∀X.¬A^+
        $$
      </td>
    </tr>
    <tr>
      <th colspan="4"><a name="core">Core</a></th>
    </tr>
    <tr>
      <td colspan="2">
        $$
        \begin{prooftree}
        \hskip -10pt
        \LeftLabel{$\mathit{init}$}
        \AxiomC{}
        \UnaryInfC{$A ⊢ A$}
        \end{prooftree}
        \begin{prooftree}
        \hskip 10pt
        \RightLabel{$\ \mathit{cut}$}
        \AxiomC{$Γ ⊢ Δ, A$}
        \AxiomC{$A, Γ ⊢ Δ$}
        \BinaryInfC{$Γ ⊢ Δ$}
        \end{prooftree}
        $$
      </td>
      <td colspan="2">
        <p>The init and cut rules are quite common to sequent (and other) calculi. This presentation clarifies a couple of useful properties.</p>
        <p>init allows us to begin a proof (or end one, working bottom-up as we often do, from goal to premise) with a proposition given to us. Under Curry-Howard’s interpretation of proofs as programs, we can understand this as the polymorphic identity function, <code>id</code>. (Sequent calculus proofs in particular correspond to higher-order programs, e.g. functions taking functions to functions.)</p>
        <p>cut instead allows us to prove a sequent by introducing and immediately eliminating a proposition in its premises. Again taking sequents as analogues of function types, we can think of it as the <em>composition</em> of proofs with compatible consequents and hypotheses.</p>
        <p>Furthermore, cut and init form a category, where the morphisms are sequents between contexts, joined by cuts. The Curry-Howard correspondence holds up here, too: <code>id</code> and function composition give a category of functions between types.</p>
      </td>
    </tr>
    <tr>
      <th colspan="4"><a name="structural">Structural</a></th>
    </tr>
    <tr>
      <td colspan="2">
        <p>Structural rules governing our use of the context. Without these, our logic would be classical <em>linear</em> logic (and would have to adjust the multiplicative and cut rules to split the context between premises). The rules are given their traditional names here, but since we mostly operate bottom-up, starting with the goal given by the syntax of a program, they actually have the exact opposite sense for us.</p>
        <p>Top-down, weaken introduces an arbitrary hypothesis or consequent. An extra hypothesis weakens the proof because more information must be provided to prove the same conclusion. An extra conclusion instead weakens what we can learn from it. Contraction, meanwhile, eliminates redundant information from the context.</p>
        <p>Bottom-up, weakening instead <em>strengthens</em> a premise, tightening its requirements and guarantees. In reality, however, this mostly amounts to bookkeeping, removing propositions that are in the way of some goal. Contraction, meanwhile, allows us to duplicate information we already know, again primarily as a way of getting one’s ducks in a row for the benefit of proof search. e.g. init proves a minimalistic A ⊢ A. Weakening is often required to whittle sequents down for init to apply.</p>
        <p>Note that the customary exchange rule is not required as this presentation’s contexts are unordered.</p>
      </td>
      <td colspan="2">
        $$
        \begin{prooftree}
        \hskip -10pt
        \def\labelSpacing{8pt}
        \LeftLabel{$\mathit{weaken} ⊢$}
        \Axiom$\fCenter Γ ⊢ Δ$
        \UnaryInf$A, \fCenter Γ ⊢ Δ$
        \end{prooftree}
        \begin{prooftree}
        \hskip 10pt
        \def\labelSpacing{8pt}
        \RightLabel{$\ ⊢ \mathit{weaken}$}
        \Axiom$\fCenter Γ ⊢ Δ$
        \UnaryInf$\fCenter Γ ⊢ Δ, A$
        \end{prooftree}
        $$
        $$
        \begin{prooftree}
        \hskip -10pt
        \def\labelSpacing{8pt}
        \LeftLabel{$\mathit{contract} ⊢$}
        \Axiom$A, A, \fCenter Γ ⊢ Δ$
        \UnaryInf$A, \fCenter Γ ⊢ Δ$
        \end{prooftree}
        \begin{prooftree}
        \hskip 10pt
        \def\labelSpacing{8pt}
        \RightLabel{$\ ⊢ \mathit{contract}$}
        \Axiom$\fCenter Γ ⊢ Δ, A, A$
        \UnaryInf$\fCenter Γ ⊢ Δ, A$
        \end{prooftree}
        $$
      </td>
    </tr>
  </tbody>
</table>
