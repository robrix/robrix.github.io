<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
    <title>Antitypical</title>
    <link href="https://antitypical.com/feed.xml" rel="self" />
    <link href="https://antitypical.com" />
    <id>https://antitypical.com/feed.xml</id>
    <author>
        <name>Rob Rix</name>
        <email>rob.rix@me.com</email>
    </author>
    <updated>2021-08-14T00:00:00Z</updated>
    <entry>
    <title>Sequent calculus cheat sheet</title>
    <link href="https://antitypical.com/posts/2021-08-14-sequent-calculus-cheat-sheet/index.html" />
    <id>https://antitypical.com/posts/2021-08-14-sequent-calculus-cheat-sheet/index.html</id>
    <published>2021-08-14T00:00:00Z</published>
    <updated>2021-08-14T00:00:00Z</updated>
    <summary type="html"><![CDATA[<p>Rules for sequent calculus connectives, formatted as a cheat sheet.</p>
<!--more-->
<table class="borderless">
  <colgroup>
    <col class="negative">
    <col class="positive">
  </colgroup>
  <thead>
    <tr>
      <th class="neg">-</th>
      <th class="pos">+</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <th colspan="2">
        <h3 id="additive">Additive</h3>
      </th>
    </tr>
    <tr>
      <td>
        <div class="connective">
          <div class="column">
            <div class="rule">
              <div class="label"><span class="neg">&amp;</span>⊢<sub>1</sub></div>
              <div class="inference">
                <div class="premise Γ">[<span class="var neg">A</span><sup class="neg">−</sup>] <span class="context Γ">Γ</span></div>
                <div class="premise turnstile">⊢</div>
                <div class="premise Δ"><span class="context Δ">Δ</span></div>
                <span class="line-of-inference"></span>
                <div class="conclusion Γ">[<span class="var neg">A</span><sup class="neg">−</sup> <span class="neg">&amp;</span> <span class="var neg">B</span><sup class="neg">−</sup>] <span class="context Γ">Γ</span></div>
                <div class="conclusion turnstile">⊢</div>
                <div class="conclusion Δ"><span class="context Δ">Δ</span></div>
              </div>
            </div>
            <div class="rule">
              <div class="label"><span class="neg">&amp;</span>⊢<sub>2</sub></div>
              <div class="inference">
                <div class="premise Γ">[<span class="var neg">B</span><sup class="neg">−</sup>] <span class="context Γ">Γ</span></div>
                <div class="premise turnstile">⊢</div>
                <div class="premise Δ"><span class="context Δ">Δ</span></div>
                <span class="line-of-inference"></span>
                <div class="conclusion Γ">[<span class="var neg">A</span><sup class="neg">−</sup> <span class="neg">&amp;</span> <span class="var neg">B</span><sup class="neg">−</sup>] <span class="context Γ">Γ</span></div>
                <div class="conclusion turnstile">⊢</div>
                <div class="conclusion Δ"><span class="context Δ">Δ</span></div>
              </div>
            </div>
          </div>
          <div class="rule">
            <div class="inference">
              <div class="premises">
                <div class="premise"><span class="context Γ">Γ</span> ⊢ <span class="context Δ">Δ</span>, <span class="var neg">A</span><sup class="neg">−</sup></div>
                <div class="premise"><span class="context Γ">Γ</span> ⊢ <span class="context Δ">Δ</span>, <span class="var neg">B</span><sup class="neg">−</sup></div>
              </div>
              <span class="line-of-inference"></span>
              <div class="conclusion"><span class="context Γ">Γ</span> ⊢ <span class="context Δ">Δ</span>, <span class="var neg">A</span><sup class="neg">−</sup> <span class="neg">&amp;</span> <span class="var neg">B</span><sup class="neg">−</sup></div>
            </div>
            <div class="label">⊢<span class="neg">&amp;</span></div>
          </div>
          <div class="connective">
            <div class="rule">
              <p><span class="pos">~</span>(<span class="var neg">A</span><sup class="neg">−</sup> <span class="neg">&amp;</span> <span class="var neg">B</span><sup class="neg">−</sup>) ≈ <span class="pos">~</span><span class="var neg">A</span><sup class="neg">−</sup> <span class="pos">⊕</span> <span class="pos">~</span><span class="var neg">B</span><sup class="neg">−</sup></p>
            </div>
          </div>
        </div>
      </td>
      <td>
        <div class="connective">
          <div class="rule">
            <div class="label"><span class="pos">⊕</span>⊢</div>
            <div class="inference">
              <div class="premises">
                <div class="premise"><span class="var pos">A</span><sup class="pos">+</sup>, <span class="context Γ">Γ</span> ⊢ <span class="context Δ">Δ</span></div>
                <div class="premise"><span class="var pos">B</span><sup class="pos">+</sup>, <span class="context Γ">Γ</span> ⊢ <span class="context Δ">Δ</span></div>
              </div>
              <span class="line-of-inference"></span>
              <div class="conclusion"><span class="var pos">A</span><sup class="pos">+</sup> <span class="pos">⊕</span> <span class="var pos">B</span><sup class="pos">+</sup>, <span class="context Γ">Γ</span> ⊢ <span class="context Δ">Δ</span></div>
            </div>
          </div>
          <div class="column">
            <div class="rule">
              <div class="inference">
                <div class="premise Γ"><span class="context Γ">Γ</span></div>
                <div class="premise turnstile">⊢</div>
                <div class="premise Δ"><span class="context Δ">Δ</span> [<span class="var pos">A</span><sup class="pos">+</sup>]</div>
                <span class="line-of-inference"></span>
                <div class="conclusion Γ"><span class="context Γ">Γ</span></div>
                <div class="conclusion turnstile">⊢</div>
                <div class="conclusion Δ"><span class="context Δ">Δ</span> [<span class="var pos">A</span><sup class="pos">+</sup> <span class="pos">⊕</span> <span class="var pos">B</span><sup class="pos">+</sup>]</div>
              </div>
              <div class="label">⊢<span class="pos">⊕</span><sub>1</sub></div>
            </div>
            <div class="rule">
              <div class="inference">
                <div class="premise Γ"><span class="context Γ">Γ</span></div>
                <div class="premise turnstile">⊢</div>
                <div class="premise Δ"><span class="context Δ">Δ</span> [<span class="var pos">B</span><sup class="pos">+</sup>]</div>
                <span class="line-of-inference"></span>
                <div class="conclusion Γ"><span class="context Γ">Γ</span></div>
                <div class="conclusion turnstile">⊢</div>
                <div class="conclusion Δ"><span class="context Δ">Δ</span> [<span class="var pos">A</span><sup class="pos">+</sup> <span class="pos">⊕</span> <span class="var pos">B</span><sup class="pos">+</sup>]</div>
              </div>
              <div class="label">⊢<span class="pos">⊕</span><sub>2</sub></div>
            </div>
          </div>
          <div class="connective">
            <div class="rule">
              <p><span class="neg">¬</span>(<span class="var pos">A</span><sup class="pos">+</sup> <span class="pos">⊕</span> <span class="var pos">B</span><sup class="pos">+</sup>) ≈ <span class="pos">~</span><span class="var pos">A</span><sup class="pos">+</sup> <span class="neg">&amp;</span> <span class="pos">~</span><span class="var pos">B</span><sup class="pos">+</sup></p>
            </div>
          </div>
        </div>
      </td>
    </tr>
    <tr>
      <td>
        <div class="connective">
          <div class="rule">
            <p>no rule for <span class="neg">⊤</span>⊢</p>
          </div>
          <div class="rule">
            <div class="inference">
              <div class="axiom"></div>
              <span class="line-of-inference"></span>
              <div class="conclusion"><span class="context Γ">Γ</span> ⊢ <span class="context Δ">Δ</span>, <span class="neg">⊤</span></div>
            </div>
            <div class="label">⊢<span class="neg">⊤</span></div>
          </div>
          <div class="connective">
            <div class="rule">
              <p><span class="pos">~</span><span class="neg">⊤</span> ≈ <span class="pos">0</span></p>
            </div>
          </div>
        </div>
      </td>
      <td>
        <div class="connective">
          <div class="rule">
            <div class="label"><span class="pos">0</span>⊢</div>
            <div class="inference">
              <div class="axiom"></div>
              <span class="line-of-inference"></span>
              <div class="conclusion"><span class="pos">0</span>, <span class="context Γ">Γ</span> ⊢ <span class="context Δ">Δ</span></div>
            </div>
          </div>
          <div class="rule">
            <p>no rule for ⊢<span class="pos">0</span></p>
          </div>
          <div class="connective">
            <div class="rule">
              <p><span class="pos">~</span><span class="neg">⊤</span> ≈ <span class="pos">0</span></p>
            </div>
          </div>
        </div>
      </td>
    </tr>
  </tbody>
  <tbody>
    <tr>
      <th colspan="2">
        <h3 id="multiplicative">Multiplicative</h3>
      </th>
    </tr>
    <tr>
      <td>
        <div class="connective">
          <div class="rule">
            <div class="label"><span class="neg">⅋</span>⊢</div>
            <div class="inference">
              <div class="premises">
                <div class="premise">[<span class="var neg">A</span><sup class="neg">−</sup>] <span class="context Γ">Γ</span> ⊢ <span class="context Δ">Δ</span></div>
                <div class="premise">[<span class="var neg">B</span><sup class="neg">−</sup>] <span class="context Γ">Γ</span> ⊢ <span class="context Δ">Δ</span></div>
              </div>
              <span class="line-of-inference"></span>
              <div class="conclusion">[<span class="var neg">A</span><sup class="neg">−</sup> <span class="neg">⅋</span> <span class="var neg">B</span><sup class="neg">−</sup>] <span class="context Γ">Γ</span> ⊢ <span class="context Δ">Δ</span></div>
            </div>
          </div>
          <div class="rule">
            <div class="inference">
              <div class="premise Γ"><span class="context Γ">Γ</span></div>
              <div class="premise turnstile">⊢</div>
              <div class="premise Δ"><span class="context Δ">Δ</span>, <span class="var neg">A</span><sup class="neg">−</sup>, <span class="var neg">B</span><sup class="neg">−</sup></div>
              <span class="line-of-inference"></span>
              <div class="conclusion Γ"><span class="context Γ">Γ</span></div>
              <div class="conclusion turnstile">⊢</div>
              <div class="conclusion Δ"><span class="context Δ">Δ</span>, <span class="var neg">A</span><sup class="neg">−</sup> <span class="neg">⅋</span> <span class="var neg">B</span><sup class="neg">−</sup></div>
            </div>
            <div class="label">⊢<span class="neg">⅋</span></div>
          </div>
          <div class="connective">
            <div class="rule">
              <p><span class="pos">~</span>(<span class="var neg">A</span><sup class="neg">−</sup> <span class="neg">⅋</span> <span class="var neg">B</span><sup class="neg">−</sup>) ≈ <span class="pos">~</span><span class="var neg">A</span><sup class="neg">−</sup> <span class="pos">⊗</span> <span class="pos">~</span><span class="var neg">B</span><sup class="neg">−</sup></p>
            </div>
          </div>
        </div>
      </td>
      <td>
        <div class="connective">
          <div class="rule">
            <div class="label"><span class="pos">⊗</span>⊢</div>
            <div class="inference">
              <div class="premise Γ"><span class="var pos">A</span><sup class="pos">+</sup>, <span class="var pos">B</span><sup class="pos">+</sup>, <span class="context Γ">Γ</span></div>
              <div class="premise turnstile">⊢</div>
              <div class="premise Δ"><span class="context Δ">Δ</span></div>
              <span class="line-of-inference"></span>
              <div class="conclusion Γ"><span class="var pos">A</span><sup class="pos">+</sup> <span class="pos">⊗</span> <span class="var pos">B</span><sup class="pos">+</sup>, <span class="context Γ">Γ</span></div>
              <div class="conclusion turnstile">⊢</div>
              <div class="conclusion Δ"><span class="context Δ">Δ</span></div>
            </div>
          </div>
          <div class="rule">
            <div class="inference">
              <div class="premises">
                <div class="premise"><span class="context Γ">Γ</span> ⊢ <span class="context Δ">Δ</span> [<span class="var pos">A</span><sup class="pos">+</sup>]</div>
                <div class="premise"><span class="context Γ">Γ</span> ⊢ <span class="context Δ">Δ</span> [<span class="var pos">B</span><sup class="pos">+</sup>]</div>
              </div>
              <span class="line-of-inference"></span>
              <div class="conclusion"><span class="context Γ">Γ</span> ⊢ <span class="context Δ">Δ</span> [<span class="var pos">A</span><sup class="pos">+</sup> <span class="pos">⊗</span> <span class="var pos">B</span><sup class="pos">+</sup>]</div>
            </div>
            <div class="label">⊢<span class="pos">⊗</span></div>
          </div>
          <div class="connective">
            <div class="rule">
              <p><span class="neg">¬</span>(<span class="var pos">A</span><sup class="pos">+</sup> <span class="pos">⊗</span> <span class="var pos">B</span><sup class="pos">+</sup>) ≈ <span class="pos">~</span><span class="var pos">A</span><sup class="pos">+</sup> <span class="neg">⅋</span> <span class="pos">~</span><span class="var pos">B</span><sup class="pos">+</sup></p>
            </div>
          </div>
        </div>
      </td>
    </tr>
    <tr>
      <td>
        <div class="connective">
          <div class="rule">
            <div class="label"><span class="neg">⊥</span><sub class="R">R</sub>⊢<sub class="R">R</sub></div>
            <div class="inference">
              <div class="axiom"></div>
              <span class="line-of-inference"></span>
              <div class="conclusion">[<span class="neg">⊥</span><sub class="R">R</sub>] <span class="context Γ">Γ</span> ⊢<sub class="R">R</sub> <span class="context Δ">Δ</span></div>
            </div>
          </div>
          <div class="rule">
            <div class="inference">
              <div class="premise Γ"><span class="context Γ">Γ</span></div>
              <div class="premise turnstile">⊢<sub class="R">R</sub></div>
              <div class="premise Δ"><span class="context Δ">Δ</span></div>
              <span class="line-of-inference"></span>
              <div class="conclusion Γ"><span class="context Γ">Γ</span></div>
              <div class="conclusion turnstile">⊢<sub class="R">R</sub></div>
              <div class="conclusion Δ"><span class="context Δ">Δ</span>, <span class="neg">⊥</span><sub class="R">R</sub></div>
            </div>
            <div class="label">⊢<span class="neg">⊥</span><sub class="R">R</sub></div>
          </div>
          <div class="connective">
            <div class="rule">
              <p><span class="pos">~</span><span class="neg">⊥</span><sub class="R">R</sub> ≈ <span class="pos">1</span><sub class="E">E</sub></p>
            </div>
          </div>
        </div>
      </td>
      <td>
        <div class="connective">
          <div class="rule">
            <div class="label"><span class="pos">1</span><sub class="E">E</sub>⊢<sub class="E">E</sub></div>
            <div class="inference">
              <div class="premise Γ"><span class="context Γ">Γ</span></div>
              <div class="premise turnstile">⊢<sub class="E">E</sub></div>
              <div class="premise Δ"><span class="context Δ">Δ</span></div>
              <span class="line-of-inference"></span>
              <div class="conclusion Γ"><span class="pos">1</span><sub class="E">E</sub>, <span class="context Γ">Γ</span></div>
              <div class="conclusion turnstile">⊢<sub class="E">E</sub></div>
              <div class="conclusion Δ"><span class="context Δ">Δ</span></div>
            </div>
          </div>
          <div class="rule">
            <div class="inference">
              <div class="axiom"></div>
              <span class="line-of-inference"></span>
              <div class="conclusion"><span class="context Γ">Γ</span> ⊢<sub class="E">E</sub> <span class="context Δ">Δ</span> [<span class="pos">1</span><sub class="E">E</sub>]</div>
            </div>
            <div class="label">⊢<sub class="E">E</sub><span class="pos">1</span><sub class="E">E</sub></div>
          </div>
          <div class="connective">
            <div class="rule">
              <p><span class="neg">¬</span><span class="pos">1</span><sub class="E">E</sub> ≈ <span class="neg">⊥</span><sub class="R">R</sub></p>
            </div>
          </div>
        </div>
      </td>
    </tr>
  </tbody>
  <tbody>
    <tr>
      <th colspan="2">
        <h3 id="implicative">Implicative</h3>
      </th>
    </tr>
    <tr>
      <td>
        <div class="connective">
          <div class="rule">
            <div class="label"><span class="neg">→</span>⊢</div>
            <div class="inference">
              <div class="premises">
                <div class="premise"><span class="context Γ">Γ</span> ⊢ <span class="context Δ">Δ</span> [<span class="var pos">A</span><sup class="pos">+</sup>]</div>
                <div class="premise">[<span class="var neg">B</span><sup class="neg">−</sup>] <span class="context Γ">Γ</span> ⊢ <span class="context Δ">Δ</span></div>
              </div>
              <span class="line-of-inference"></span>
              <div class="conclusion">[<span class="var pos">A</span><sup class="pos">+</sup> <span class="neg">→</span> <span class="var neg">B</span><sup class="neg">−</sup>] <span class="context Γ">Γ</span> ⊢ <span class="context Δ">Δ</span></div>
            </div>
          </div>
          <div class="rule">
            <div class="inference">
              <div class="premise Γ"><span class="var pos">A</span><sup class="pos">+</sup>, <span class="context Γ">Γ</span></div>
              <div class="premise turnstile">⊢</div>
              <div class="premise Δ"><span class="context Δ">Δ</span>, <span class="var neg">B</span><sup class="neg">−</sup></div>
              <span class="line-of-inference"></span>
              <div class="conclusion Γ"><span class="context Γ">Γ</span></div>
              <div class="conclusion turnstile">⊢</div>
              <div class="conclusion Δ"><span class="context Δ">Δ</span>, <span class="var pos">A</span><sup class="pos">+</sup> <span class="neg">→</span> <span class="var neg">B</span><sup class="neg">−</sup></div>
            </div>
            <div class="label">⊢<span class="neg">→</span></div>
          </div>
          <div class="connective">
            <div class="rule">
              <p><span class="pos">~</span>(<span class="var pos">A</span><sup class="pos">+</sup> <span class="neg">→</span> <span class="var neg">B</span><sup class="neg">−</sup>) ≈ <span class="var neg">B</span><sup class="neg">−</sup> <span class="pos">⤚</span> <span class="var pos">A</span><sup class="pos">+</sup></p>
            </div>
          </div>
        </div>
      </td>
      <td>
        <div class="connective">
          <div class="rule">
            <div class="label"><span class="pos">⤚</span>⊢</div>
            <div class="inference">
              <div class="premise Γ"><span class="var pos">A</span><sup class="pos">+</sup>, <span class="context Γ">Γ</span></div>
              <div class="premise turnstile">⊢</div>
              <div class="premise Δ"><span class="context Δ">Δ</span>, <span class="var neg">B</span><sup class="neg">−</sup></div>
              <span class="line-of-inference"></span>
              <div class="conclusion Γ"><span class="var neg">B</span><sup class="neg">−</sup> <span class="pos">⤚</span> <span class="var pos">A</span><sup class="pos">+</sup>, <span class="context Γ">Γ</span></div>
              <div class="conclusion turnstile">⊢</div>
              <div class="conclusion Δ"><span class="context Δ">Δ</span></div>
            </div>
          </div>
          <div class="rule">
            <div class="inference">
              <div class="premises">
                <div class="premise"><span class="context Γ">Γ</span> ⊢ <span class="context Δ">Δ</span> [<span class="var pos">A</span><sup class="pos">+</sup>]</div>
                <div class="premise">[<span class="var neg">B</span><sup class="neg">−</sup>] <span class="context Γ">Γ</span> ⊢ <span class="context Δ">Δ</span></div>
              </div>
              <span class="line-of-inference"></span>
              <div class="conclusion"><span class="context Γ">Γ</span> ⊢ <span class="context Δ">Δ</span> [<span class="var neg">B</span><sup class="neg">−</sup> <span class="pos">⤚</span> <span class="var pos">A</span><sup class="pos">+</sup>]</div>
            </div>
            <div class="label">⊢<span class="pos">⤚</span></div>
          </div>
          <div class="connective">
            <div class="rule">
              <p><span class="neg">¬</span>(<span class="var neg">B</span><sup class="neg">−</sup> <span class="pos">⤚</span> <span class="var pos">A</span><sup class="pos">+</sup>) ≈ <span class="var pos">A</span><sup class="pos">+</sup> <span class="neg">→</span> <span class="var neg">B</span><sup class="neg">−</sup></p>
            </div>
          </div>
        </div>
      </td>
    </tr>
  </tbody>
  <tbody>
    <tr>
      <th colspan="2">
        <h3 id="negation">Negation</h3>
      </th>
    </tr>
    <tr>
      <td>
        <div class="connective">
          <div class="rule">
            <div class="label"><span class="neg">¬</span>⊢</div>
            <div class="inference">
              <div class="premise Γ"><span class="context Γ">Γ</span></div>
              <div class="premise turnstile">⊢</div>
              <div class="premise Δ"><span class="context Δ">Δ</span> [<span class="var pos">A</span><sup class="pos">+</sup>]</div>
              <span class="line-of-inference"></span>
              <div class="conclusion Γ">[<span class="neg">¬</span><span class="var pos">A</span><sup class="pos">+</sup>] <span class="context Γ">Γ</span></div>
              <div class="conclusion turnstile">⊢</div>
              <div class="conclusion Δ"><span class="context Δ">Δ</span></div>
            </div>
          </div>
          <div class="rule">
            <div class="inference">
              <div class="premise Γ"><span class="var pos">A</span><sup class="pos">+</sup>, <span class="context Γ">Γ</span></div>
              <div class="premise turnstile">⊢</div>
              <div class="premise Δ"><span class="context Δ">Δ</span></div>
              <span class="line-of-inference"></span>
              <div class="conclusion Γ"><span class="context Γ">Γ</span></div>
              <div class="conclusion turnstile">⊢</div>
              <div class="conclusion Δ"><span class="context Δ">Δ</span>, <span class="neg">¬</span><span class="var pos">A</span><sup class="pos">+</sup></div>
            </div>
            <div class="label">⊢<span class="neg">¬</span></div>
          </div>
          <div class="connective">
            <div class="rule">
              <p><span class="pos">~</span><span class="neg">¬</span><span class="var pos">A</span><sup class="pos">+</sup> ≈ <span class="var pos">A</span><sup class="pos">+</sup></p>
            </div>
          </div>
        </div>
      </td>
      <td>
        <div class="connective">
          <div class="rule">
            <div class="label"><span class="pos">~</span>⊢</div>
            <div class="inference">
              <div class="premise Γ"><span class="context Γ">Γ</span></div>
              <div class="premise turnstile">⊢</div>
              <div class="premise Δ"><span class="context Δ">Δ</span>, <span class="var neg">A</span><sup class="neg">−</sup></div>
              <span class="line-of-inference"></span>
              <div class="conclusion Γ"><span class="pos">~</span><span class="var neg">A</span><sup class="neg">−</sup>, <span class="context Γ">Γ</span></div>
              <div class="conclusion turnstile">⊢</div>
              <div class="conclusion Δ"><span class="context Δ">Δ</span></div>
            </div>
          </div>
          <div class="rule">
            <div class="inference">
              <div class="premise Γ">[<span class="var neg">A</span><sup class="neg">−</sup>] <span class="context Γ">Γ</span></div>
              <div class="premise turnstile">⊢</div>
              <div class="premise Δ"><span class="context Δ">Δ</span></div>
              <span class="line-of-inference"></span>
              <div class="conclusion Γ"><span class="context Γ">Γ</span></div>
              <div class="conclusion turnstile">⊢</div>
              <div class="conclusion Δ"><span class="context Δ">Δ</span> [<span class="pos">~</span><span class="var neg">A</span><sup class="neg">−</sup>]</div>
            </div>
            <div class="label">⊢<span class="pos">~</span></div>
          </div>
          <div class="connective">
            <div class="rule">
              <p><span class="neg">¬</span><span class="pos">~</span><span class="var neg">A</span><sup class="neg">−</sup> ≈ <span class="var neg">A</span><sup class="neg">−</sup></p>
            </div>
          </div>
        </div>
      </td>
    </tr>
  </tbody>
  <tbody>
    <tr>
      <th scope="row">
        <h3 id="assertion">Assertion</h3>
      </th>
    </tr>
    <tr>
      <td>
        <div class="connective">
          <div class="rule">
            <div class="label"><span class="neg">¬̷</span>⊢</div>
            <div class="inference">
              <div class="premise Γ">[<span class="var neg">A</span><sup class="neg">−</sup>] <span class="context Γ">Γ</span></div>
              <div class="premise turnstile">⊢</div>
              <div class="premise Δ"><span class="context Δ">Δ</span></div>
              <span class="line-of-inference"></span>
              <div class="conclusion Γ">[<span class="neg">¬̷</span><span class="var neg">A</span><sup class="neg">−</sup>] <span class="context Γ">Γ</span></div>
              <div class="conclusion turnstile">⊢</div>
              <div class="conclusion Δ"><span class="context Δ">Δ</span></div>
            </div>
          </div>
          <div class="rule">
            <div class="inference">
              <div class="premise Γ"><span class="context Γ">Γ</span></div>
              <div class="premise turnstile">⊢</div>
              <div class="premise Δ"><span class="context Δ">Δ</span>, <span class="var neg">A</span><sup class="neg">−</sup></div>
              <span class="line-of-inference"></span>
              <div class="conclusion Γ"><span class="context Γ">Γ</span></div>
              <div class="conclusion turnstile">⊢</div>
              <div class="conclusion Δ"><span class="context Δ">Δ</span>, <span class="neg">¬̷</span><span class="var neg">A</span><sup class="neg">−</sup></div>
            </div>
            <div class="label">⊢<span class="neg">¬̷</span></div>
          </div>
          <div class="connective">
            <div class="rule">
              <p><span class="pos">~</span><span class="neg">¬̷</span><span class="var neg">A</span><sup class="neg">−</sup> ≈ <span class="var neg">A</span><sup class="neg">−</sup></p>
            </div>
          </div>
        </div>
      </td>
      <td>
        <div class="connective">
          <div class="rule">
            <div class="label"><span class="pos">✓</span>⊢</div>
            <div class="inference">
              <div class="premise Γ"><span class="var pos">A</span><sup class="pos">+</sup>, <span class="context Γ">Γ</span></div>
              <div class="premise turnstile">⊢</div>
              <div class="premise Δ"><span class="context Δ">Δ</span></div>
              <span class="line-of-inference"></span>
              <div class="conclusion Γ"><span class="pos">✓</span><span class="var pos">A</span><sup class="pos">+</sup>, <span class="context Γ">Γ</span></div>
              <div class="conclusion turnstile">⊢</div>
              <div class="conclusion Δ"><span class="context Δ">Δ</span></div>
            </div>
          </div>
          <div class="rule">
            <div class="inference">
              <div class="premise Γ"><span class="context Γ">Γ</span></div>
              <div class="premise turnstile">⊢</div>
              <div class="premise Δ"><span class="context Δ">Δ</span> [<span class="var pos">A</span><sup class="pos">+</sup>]</div>
              <span class="line-of-inference"></span>
              <div class="conclusion Γ"><span class="context Γ">Γ</span></div>
              <div class="conclusion turnstile">⊢</div>
              <div class="conclusion Δ"><span class="context Δ">Δ</span> [<span class="pos">✓</span><span class="var pos">A</span><sup class="pos">+</sup>]</div>
            </div>
            <div class="label">⊢<span class="pos">✓</span></div>
          </div>
          <div class="connective">
            <div class="rule">
              <p><span class="neg">¬</span><span class="pos">✓</span><span class="var pos">A</span><sup class="pos">+</sup> ≈ <span class="var pos">A</span><sup class="pos">+</sup></p>
            </div>
          </div>
        </div>
      </td>
    </tr>
  </tbody>
  <tbody>
    <tr>
      <th scope="row">
        <h3 id="shifts">Shifts</h3>
      </th>
    </tr>
    <tr>
      <td>
        <div class="connective">
          <div class="rule">
            <div class="label"><span class="neg">↑</span>⊢</div>
            <div class="inference">
              <div class="premise Γ"><span class="var pos">A</span><sup class="pos">+</sup>, <span class="context Γ">Γ</span></div>
              <div class="premise turnstile">⊢</div>
              <div class="premise Δ"><span class="context Δ">Δ</span></div>
              <span class="line-of-inference"></span>
              <div class="conclusion Γ">[<span class="neg">↑</span><span class="var pos">A</span><sup class="pos">+</sup>] <span class="context Γ">Γ</span></div>
              <div class="conclusion turnstile">⊢</div>
              <div class="conclusion Δ"><span class="context Δ">Δ</span></div>
            </div>
          </div>
          <div class="rule">
            <div class="inference">
              <div class="premise Γ"><span class="context Γ">Γ</span></div>
              <div class="premise turnstile">⊢</div>
              <div class="premise Δ"><span class="context Δ">Δ</span> [<span class="var pos">A</span><sup class="pos">+</sup>]</div>
              <span class="line-of-inference"></span>
              <div class="conclusion Γ"><span class="context Γ">Γ</span></div>
              <div class="conclusion turnstile">⊢</div>
              <div class="conclusion Δ"><span class="context Δ">Δ</span>, <span class="neg">↑</span><span class="var pos">A</span><sup class="pos">+</sup></div>
            </div>
            <div class="label">⊢<span class="neg">↑</span></div>
          </div>
          <div class="connective">
            <div class="rule">
              <p>(<span class="var">A</span> <span class="neg">→</span> <span class="var neg">B</span><sup class="neg">−</sup>)<sup class="neg">N</sup> = <span class="pos">↓</span>(<span class="var">A</span><sup class="neg">N</sup>) <span class="neg">→</span> <span class="var neg">B</span><sup class="neg">−</sup></p>
            </div>
          </div>
        </div>
      </td>
      <td>
        <div class="connective">
          <div class="rule">
            <div class="label"><span class="pos">↓</span>⊢</div>
            <div class="inference">
              <div class="premise Γ">[<span class="var neg">A</span><sup class="neg">−</sup>] <span class="context Γ">Γ</span></div>
              <div class="premise turnstile">⊢</div>
              <div class="premise Δ"><span class="context Δ">Δ</span></div>
              <span class="line-of-inference"></span>
              <div class="conclusion Γ"><span class="pos">↓</span><span class="var neg">A</span><sup class="neg">−</sup>, <span class="context Γ">Γ</span></div>
              <div class="conclusion turnstile">⊢</div>
              <div class="conclusion Δ"><span class="context Δ">Δ</span></div>
            </div>
          </div>
          <div class="rule">
            <div class="inference">
              <div class="premise Γ"><span class="context Γ">Γ</span></div>
              <div class="premise turnstile">⊢</div>
              <div class="premise Δ"><span class="context Δ">Δ</span>, <span class="var neg">A</span><sup class="neg">−</sup></div>
              <span class="line-of-inference"></span>
              <div class="conclusion Γ"><span class="context Γ">Γ</span></div>
              <div class="conclusion turnstile">⊢</div>
              <div class="conclusion Δ"><span class="context Δ">Δ</span> [<span class="pos">↓</span><span class="var neg">A</span><sup class="neg">−</sup>]</div>
            </div>
            <div class="label">⊢<span class="pos">↓</span></div>
          </div>
          <div class="connective">
            <div class="rule">
              <p>(<span class="var">A</span> <span class="neg">→</span> <span class="var">B</span>)<sup class="pos">V</sup> = <span class="pos">↓</span>(<span class="var">A</span><sup class="pos">V</sup> <span class="neg">→</span> <span class="neg">↑</span>(<span class="var">B</span><sup class="pos">V</sup>))</p>
            </div>
          </div>
        </div>
      </td>
    </tr>
  </tbody>
  <tbody>
    <tr>
      <th colspan="2">
        <h3 id="quantification">Quantification</h3>
      </th>
    </tr>
    <tr>
      <td>
        <div class="connective">
          <div class="rule">
            <div class="label"><span class="neg">∀</span>⊢</div>
            <div class="inference">
              <div class="premise Γ">[<span class="var neg">A</span><sup class="neg">−</sup>{<span class="var">B</span>/<span class="var">X</span>}] <span class="context Γ">Γ</span></div>
              <div class="premise turnstile">⊢</div>
              <div class="premise Δ"><span class="context Δ">Δ</span></div>
              <span class="line-of-inference"></span>
              <div class="conclusion Γ">[<span class="neg">∀</span><span class="var">X</span>.<span class="var neg">A</span><sup class="neg">−</sup>] <span class="context Γ">Γ</span></div>
              <div class="conclusion turnstile">⊢</div>
              <div class="conclusion Δ"><span class="context Δ">Δ</span></div>
            </div>
          </div>
          <div class="rule right">
            <div class="inference">
              <div class="premises">
                <div class="premise"><span class="context Γ">Γ</span> ⊢ <span class="context Δ">Δ</span>, <span class="var neg">A</span><sup class="neg">−</sup></div>
                <div class="side-condition"><span class="var">X</span> ∉ <span class="function">fv</span>(<span class="context Γ">Γ</span> ⊢ <span class="context Δ">Δ</span>)</div>
              </div>
              <span class="line-of-inference"></span>
              <div class="conclusion"><span class="context Γ">Γ</span> ⊢ <span class="context Δ">Δ</span>, <span class="neg">∀</span><span class="var">X</span>.<span class="var neg">A</span><sup class="neg">−</sup></div>
            </div>
            <div class="label">⊢<span class="neg">∀</span></div>
          </div>
          <div class="connective">
            <div class="rule">
              <p><span class="pos">~</span>(<span class="neg">∀</span><span class="var">X</span>.<span class="var neg">A</span><sup class="neg">−</sup>) ≈ <span class="pos">∃</span><span class="var">X</span>.<span class="pos">~</span><span class="var neg">A</span><sup class="neg">−</sup></p>
            </div>
          </div>
        </div>
      </td>
      <td>
        <div class="connective">
          <div class="rule left">
            <div class="label"><span class="pos">∃</span>⊢</div>
            <div class="inference">
              <div class="premises">
                <div class="side-condition"><span class="var">X</span> ∉ <span class="function">fv</span>(<span class="context Γ">Γ</span> ⊢ <span class="context Δ">Δ</span>)</div>
                <div class="premise"><span class="var pos">A</span><sup class="pos">+</sup>, <span class="context Γ">Γ</span> ⊢ <span class="context Δ">Δ</span></div>
              </div>
              <span class="line-of-inference"></span>
              <div class="conclusion"><span class="pos">∃</span><span class="var">X</span>.<span class="var pos">A</span><sup class="pos">+</sup>, <span class="context Γ">Γ</span> ⊢ <span class="context Δ">Δ</span></div>
            </div>
          </div>
          <div class="rule">
            <div class="inference">
              <div class="premise Γ"><span class="context Γ">Γ</span></div>
              <div class="premise turnstile">⊢</div>
              <div class="premise Δ"><span class="context Δ">Δ</span> [<span class="var pos">A</span><sup class="pos">+</sup>{<span class="var">B</span>/<span class="var">X</span>}]</div>
              <span class="line-of-inference"></span>
              <div class="conclusion Γ"><span class="context Γ">Γ</span></div>
              <div class="conclusion turnstile">⊢</div>
              <div class="conclusion Δ"><span class="context Δ">Δ</span> [<span class="pos">∃</span><span class="var">X</span>.<span class="var pos">A</span><sup class="pos">+</sup>]</div>
            </div>
            <div class="label">⊢<span class="pos">∃</span></div>
          </div>
          <div class="connective">
            <div class="rule">
              <p><span class="neg">¬</span>(<span class="pos">∃</span><span class="var">X</span>.<span class="var pos">A</span><sup class="pos">+</sup>) ≈ <span class="neg">∀</span><span class="var">X</span>.<span class="neg">¬</span><span class="var pos">A</span><sup class="pos">+</sup></p>
            </div>
          </div>
        </div>
      </td>
    </tr>
  </tbody>
  <tbody>
    <tr>
      <th scope="row">
        <h3 id="core">Core</h3>
      </th>
    </tr>
    <tr>
      <td>
        <div class="connective">
          <div class="rule">
            <div class="inference">
              <div class="axiom"></div>
              <span class="line-of-inference"></span>
              <div class="conclusion Γ"><span class="var">A</span></div>
              <div class="conclusion turnstile">⊢</div>
              <div class="conclusion Δ"><span class="var">A</span></div>
            </div>
            <div class="label"><span class="function">init</span></div>
          </div>
        </div>
      </td>
      <td>
        <div class="connective">
          <div class="rule">
            <div class="inference">
              <div class="premises">
                <div class="premise"><span class="context Γ">Γ</span> ⊢ <span class="context Δ">Δ</span>, <span class="var">A</span></div>
                <div class="premise"><span class="var">A</span>, <span class="context Γ">Γ</span> ⊢ <span class="context Δ">Δ</span></div>
              </div>
              <span class="line-of-inference"></span>
              <div class="conclusion"><span class="context Γ">Γ</span> ⊢ <span class="context Δ">Δ</span></div>
            </div>
            <div class="label"><span class="function">cut</span></div>
          </div>
        </div>
      </td>
    </tr>
  </tbody>
  <tbody>
    <tr>
      <th scope="row">
        <h3 id="structural">Structural</h3>
      </th>
    </tr>
    <tr>
      <td>
        <div class="connective">
          <div class="rule">
            <div class="label"><span class="function">weaken</span> ⊢</div>
            <div class="inference">
              <div class="premise Γ"><span class="context Γ">Γ</span></div>
              <div class="premise turnstile">⊢</div>
              <div class="premise Δ"><span class="context Δ">Δ</span></div>
              <span class="line-of-inference"></span>
              <div class="conclusion Γ"><span class="var">A</span>, <span class="context Γ">Γ</span></div>
              <div class="conclusion turnstile">⊢</div>
              <div class="conclusion Δ"><span class="context Δ">Δ</span></div>
            </div>
          </div>
          <div class="rule">
            <div class="inference">
              <div class="premise Γ"><span class="context Γ">Γ</span></div>
              <div class="premise turnstile">⊢</div>
              <div class="premise Δ"><span class="context Δ">Δ</span></div>
              <span class="line-of-inference"></span>
              <div class="conclusion Γ"><span class="context Γ">Γ</span></div>
              <div class="conclusion turnstile">⊢</div>
              <div class="conclusion Δ"><span class="context Δ">Δ</span>, <span class="var">A</span></div>
            </div>
            <div class="label">⊢ <span class="function">weaken</span></div>
          </div>
        </div>
      </td>
      <td>
        <div class="connective">
          <div class="rule">
            <div class="label"><span class="function">contract</span> ⊢</div>
            <div class="inference">
              <div class="premise Γ"><span class="var">A</span>, <span class="var">A</span>, <span class="context Γ">Γ</span></div>
              <div class="premise turnstile">⊢</div>
              <div class="premise Δ"><span class="context Δ">Δ</span></div>
              <span class="line-of-inference"></span>
              <div class="conclusion Γ"><span class="var">A</span>, <span class="context Γ">Γ</span></div>
              <div class="conclusion turnstile">⊢</div>
              <div class="conclusion Δ"><span class="context Δ">Δ</span></div>
            </div>
          </div>
          <div class="rule">
            <div class="inference">
              <div class="premise Γ"><span class="context Γ">Γ</span></div>
              <div class="premise turnstile">⊢</div>
              <div class="premise Δ"><span class="context Δ">Δ</span>, <span class="var">A</span>, <span class="var">A</span></div>
              <span class="line-of-inference"></span>
              <div class="conclusion Γ"><span class="context Γ">Γ</span></div>
              <div class="conclusion turnstile">⊢</div>
              <div class="conclusion Δ"><span class="context Δ">Δ</span>, <span class="var">A</span></div>
            </div>
            <div class="label">⊢ <span class="function">contract</span></div>
          </div>
        </div>
      </td>
    </tr>
  </tbody>
</table>]]></summary>
</entry>
<entry>
    <title>When Howard Met Curry</title>
    <link href="https://antitypical.com/posts/2021-07-28-when-howard-met-curry/index.html" />
    <id>https://antitypical.com/posts/2021-07-28-when-howard-met-curry/index.html</id>
    <published>2021-07-28T20:31:49Z</published>
    <updated>2021-07-28T20:31:49Z</updated>
    <summary type="html"><![CDATA[<p>The Curry-Howard correspondence is a map for moving between logic and type theory, relating propositions with types and proofs with programs. It describes a two-way street, and we can freely move between the two worlds, or perhaps merely two <em>perspectives</em>, so long as we follow the map.</p>
<p>Sometimes the road takes us to unexpected places. Here’s a trip I’ve been on recently.</p>
<!--more-->
<h2 id="double-negation">Double negation</h2>
<p>I’ve been working on a language named <a href="https://github.com/robrix/sequoia"><code>sequoia</code></a>, which embeds polarized classical logic in Haskell. Of course, Haskell corresponds to an intuitionistic logic, so we can’t just bring arbitrary classical proofs over directly. We have to use a double-negation translation, importing classical propositions A as intuitionistic propositions ¬¬A. There are several such translations named (and infinitely more possible), differing in how many negations are placed where, but they all get the job done.</p>
<p>Curry-Howard tells us a translation for negations, but we can work this one out ourselves with a little logical knowledge: a negation ¬A can also be encoded as the implication A → ⊥. It’s straightforward enough: “A implies falsehood” means the same thing as “not A.”</p>
<p>Implications translate to functions, but what about ⊥? That simplest, yet perhaps initially baffling, of algebraic datatypes, the empty type. We can define these for ourselves, but there’s a standard definition in the <code>Data.Void</code> module:</p>
<div class="sourceCode" id="cb1"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb1-1"><a href="#cb1-1" aria-hidden="true"></a><span class="kw">data</span> <span class="dt">Void</span></span></code></pre></div>
<p>Having no constructors, <code>Void</code> also has no inhabitants—no proof terms—just like ⊥. So <code>Void</code> indeed corresponds to ⊥. So what kind of thing is <code>A -&gt; Void</code>? A function returning <code>Void</code> is a function that <em>cannot</em> return; it can only pass control along to <em>another</em> function returning <code>Void</code>. In other words, <code>A -&gt; Void</code> is just what Curry-Howard tells us: a continuation.</p>
<p>Thus, the double negation ¬¬A becomes a continuation from a continuation:</p>
<div class="sourceCode" id="cb2"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb2-1"><a href="#cb2-1" aria-hidden="true"></a><span class="kw">type</span> <span class="dt">DoubleNegation</span> a <span class="ot">=</span> (a <span class="ot">-&gt;</span> <span class="dt">Void</span>) <span class="ot">-&gt;</span> <span class="dt">Void</span></span></code></pre></div>
<p>which is a shape also known as continuation-passing style. Classical <em>languages</em> embed into intuitionistic ones via CPS.</p>
<p>As discussed, modelling ⊥ with <code>Void</code> extends to modelling negations ¬A (encoded A → ⊥) with continuations. Further opens the door to using logical reasoning principles relating to ⊥. For example, we can use the function <code>absurd</code>, defined as:</p>
<div class="sourceCode" id="cb3"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb3-1"><a href="#cb3-1" aria-hidden="true"></a><span class="ot">absurd ::</span> <span class="dt">Void</span> <span class="ot">-&gt;</span> a</span>
<span id="cb3-2"><a href="#cb3-2" aria-hidden="true"></a>absurd v <span class="ot">=</span> <span class="kw">case</span> v <span class="kw">of</span> {}</span></code></pre></div>
<p>to supply proofs using the principle of explosion, or ex falso quodlibet. And <code>Void</code> is an appropriately abortive substitute for ⊥, since there’s no way for control to pass through a type with no inhabitants.</p>
<p>However good a fit <code>Void</code> might be initially, it’s quite inconvenient when embedding a language within another, whether by encoding or interpretation. You typically <em>want</em> control to return, and to run code afterwards, and to collect results, to continue with the next iteration of a REPL, or to print, save, or transmit computed values, clean up acquired resources, and so on. Absent tricks like throwing values up the stack with exception handlers, you simply can’t: nothing returns from the <code>Void</code>.</p>
<p>We don’t necessarily have to use <code>Void</code> itself, however, but merely something which gives us the same proprties w.r.t. control. In particular, we can substitute <code>Void</code> out for another type, often a parameter, in our definition of <code>DoubleNegation</code>. I mentioned earlier that <code>DoubleNegation</code> is continuation-passing style, so I’m going to go ahead and spoil the punchline by renaming the type to <code>Cont</code> at the same time:</p>
<div class="sourceCode" id="cb4"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb4-1"><a href="#cb4-1" aria-hidden="true"></a><span class="kw">newtype</span> <span class="dt">Cont</span> r a <span class="ot">=</span> <span class="dt">Cont</span> {<span class="ot"> runCont ::</span> (a <span class="ot">-&gt;</span> r) <span class="ot">-&gt;</span> r }</span></code></pre></div>
<p>Control-wise, the main feature of <code>Void</code> is abortive control—it can never return, so it can only pass control to something else with the same property. <code>Cont</code> offers us the same behaviour, in that normal control flow is represented as applications of the continuation, passing control along to the next computation, while abortive control is possible by returning <code>r</code> directly.</p>
<p>By replacing <code>Void</code> with a type parameter <code>r</code> (the traditional name, perhaps for “result,”, or “return”), particularly one visible at the type level (vs. universally quantified over as with <code>Codensity</code>), we’ve also opened the door to more interesting control tricks like multi-prompt delimited control, and therefore to arbitrary effects. Handy tricks to have up your sleeve when implementing a language, to say the least.</p>
<h2 id="beginnings-and-endings">Beginnings and endings</h2>
<p>I recently wrote a post about what I termed <a href="/posts/2021-07-08-environment-passing-style/">environment-passing style</a>. A series of observations arrives at (in some sense) dual translations of <code>a -&gt; b</code> as <code>(b -&gt; r) -&gt; (a -&gt; r)</code> and <code>(e -&gt; a) -&gt; (e -&gt; b)</code> (shapes that you start seeing everywhere once you learn to think of them this way, e.g. in folds and unfolds, in Mendler-style algebras and coalgebras, in lambda encodings, etc.). Here, just as above, <code>r</code> substitutes for—indeed, it <em>abstracts</em>—⊥. What about <code>e</code>?</p>
<p>The common theme running throughout the sequent calculus is duality. <code>r</code> abstracts <code>Void</code>, <code>Void</code> corresponds to ⊥, ⊥ (negative falsity) dualizes to 1 (positive truth), 1 corresponds to <code>()</code>, <code>()</code> is abstracted to <code>e</code>. (Back and forth ’cross the Curry-Howard bridge!)</p>
<p>Earlier, we judged <code>r</code> a fitting substitute for <code>Void</code> because it behaved compatibly with respect to control. In contrast, <code>()</code> doesn’t <em>behave</em> in any way at all.</p>
<p><code>r</code>’s abstraction of <code>Void</code> is determined entirely by Curry-Howard: <code>r</code> abstracts <code>Void</code> insofar as <code>Void</code> corresponds to ⊥ and its logical rules. The left rule has this sequent as an axiom:</p>
<div class="connective">
<p><div class="rule"> <div class="label">⊥⊢</div> <div class="inference"> <div class="axiom"></div> <span class="line-of-inference"></span> <div class="conclusion Γ">⊥, Γ</div> <div class="conclusion turnstile">⊢</div> <div class="conclusion Δ">Δ, ⊥</div> </div> </div></p>
</div>
<p>This gives us ex falso quodlibet: ⊥ on the left suffices to prove <em>any</em> sequent. As we saw, <code>Void</code> provides this via <code>absurd</code>. For <code>r</code>, imagine a type representing sequents implemented using <code>Cont</code>. If your arguments contain an <code>r</code>, there’s no need to consider any other arguments or what values you could compute and return; in fact, you don’t need the continuation at all. Just return the argument of type <code>r</code> and you’re done.</p>
<p>The right rule is instead:</p>
<div class="connective">
<p><div class="rule"> <div class="inference"> <div class="premise Γ">Γ</div> <div class="premise turnstile">⊢</div> <div class="premise Δ">Δ</div> <span class="line-of-inference"></span> <div class="conclusion Γ">Γ</div> <div class="conclusion turnstile">⊢</div> <div class="conclusion Δ">Δ, ⊥</div> </div> <div class="label">⊢⊥</div> </div></p>
</div>
<p>This instead says that you can construct it along any sequent which was provable anyway; or, working bottom-up, ⊥ adds no information to a proof, and so can be discarded at any time. This one is a little stranger; we can’t construct a <code>Void</code>, period; but if we could, it certainly wouldn’t add any information. On the other hand, <code>r</code> <em>is</em> inhabited, so we can certainly follow the analogy: we can construct an <code>r</code> if we can return without it anyway; in fact, we do, by applying the return continuation.</p>
<p>For <code>e</code> we instead need to trace its relationships with 1. 1’s rules are dual, mirror images of the ones for ⊥. Again, we start with the left rule, which corresponds closely to the right rule for ⊥:</p>
<div class="connective">
<p><div class="rule"> <div class="label">1⊢</div> <div class="inference"> <div class="premise Γ">Γ</div> <div class="premise turnstile">⊢</div> <div class="premise Δ">Δ</div> <span class="line-of-inference"></span> <div class="conclusion Γ">1, Γ</div> <div class="conclusion turnstile">⊢</div> <div class="conclusion Δ">Δ</div> </div> </div></p>
</div>
<p>Left rules can be read by recalling that a sequent is sort of like a function: we can build a function to eliminate 1 and Γ into Δ by means of a funciton eliminating Γ into Δ. Put another way, 1 doesn’t give us any power to prove things that we didn’t have without it, and so we can always introduce it as a hypothetical. <code>()</code> works much the same way: adding an argument of type <code>()</code> won’t help you construct anything, since you could have just introduced it as a literal. <code>e</code> therefore must work the same way, but we’re going to weaken our informal restatement of this down to: you are free to ignore an argument of type <code>e</code>. Of course, we aren’t in an e.g. linear setting, so we’re free to ignore <em>every</em> argument. But even if we were in a linear setting, <code>e</code> should still be discardable.</p>
<p>On the right:</p>
<div class="connective">
<p><div class="rule"> <div class="inference"> <div class="axiom"></div> <span class="line-of-inference"></span> <div class="conclusion Γ">Γ</div> <div class="conclusion turnstile">⊢</div> <div class="conclusion Δ">Δ, 1</div> </div> <div class="label">⊢1</div> </div></p>
</div>
<p>You can always make a 1. Ditto <code>()</code>; it’s what makes it discardable. (1, a positive connective, is indeed defined by its right rule.) <code>e</code>, then, must also be freely introduced, ambiently, ubiquitously.</p>
<p>Considering that we started with the humble ⊥ and 1, the combined consequences of these rules and equivalences for our purposes are surprisingly useful. Expressed as derived rules, on the ⊥ side, if we have an A, we can use it to eliminate an A → ⊥<sub>R</sub>—a continuation—at any time; likwise, we can introduce a continuation from A to satisfy a demand for a A:</p>
<div class="connective">
<p><div class="rule"> <div class="label">→⊥<sub>R</sub>⊢</div> <div class="inference"> <div class="premise Γ">Γ</div> <div class="premise turnstile">⊢<sub>R</sub></div> <div class="premise Δ">Δ, A</div> <span class="line-of-inference"></span> <div class="conclusion Γ">A → ⊥<sub>R</sub>, Γ</div> <div class="conclusion turnstile">⊢<sub>R</sub></div> <div class="conclusion Δ">Δ</div> </div> </div> <div class="rule"> <div class="inference"> <div class="premise Γ">A, Γ</div> <div class="premise turnstile">⊢<sub>R</sub></div> <div class="premise Δ">Δ</div> <span class="line-of-inference"></span> <div class="conclusion Γ">Γ</div> <div class="conclusion turnstile">⊢<sub>R</sub></div> <div class="conclusion Δ">Δ, A → ⊥<sub>R</sub></div> </div> <div class="label">⊢→⊥<sub>R</sub></div> </div></p>
</div>
<p>Dually, demand for 1<sub>E</sub> → A is satisfied by demand for A; and we can always turn A into 1<sub>E</sub> → A:</p>
<div class="connective">
<p><div class="rule"> <div class="label">1<sub>E</sub>→⊢</div> <div class="inference"> <div class="premise Γ">A, Γ</div> <div class="premise turnstile">⊢<sub>E</sub></div> <div class="premise Δ">Δ</div> <span class="line-of-inference"></span> <div class="conclusion Γ">1<sub>E</sub> → A, Γ</div> <div class="conclusion turnstile">⊢<sub>E</sub></div> <div class="conclusion Δ">Δ</div> </div> </div> <div class="rule"> <div class="inference"> <div class="premise Γ">Γ</div> <div class="premise turnstile">⊢<sub>E</sub></div> <div class="premise Δ">Δ, A</div> <span class="line-of-inference"></span> <div class="conclusion Γ">Γ</div> <div class="conclusion turnstile">⊢<sub>E</sub></div> <div class="conclusion Δ">Δ, 1<sub>E</sub> → A</div> </div> <div class="label">⊢1<sub>E</sub>→</div> </div></p>
</div>
<h2 id="assertive-negativity">Assertive negativity</h2>
<p>R represents the ubiquitously available ability to jump to the end of the program and abort. E, on the other hand, represents the ubiquitously available ability to summon (already globally-available) information out of thin air: the environment (hence the name E). Neither of these give us anything <em>really</em> new—after all, we could always pass information inwards, threading it through all the intervening calls, or abort and return outwards by means of <code>Maybe</code> or the like. But doing either in a single step <em>without</em> changing the rest of the code base is pretty handy.</p>
<p>Further, <code>Cont r a</code> gives us some tools that ¬¬A alone does not, including delimited continuations. Delimited continuations allow us to jump not only to the end of the program, but to some designated intermediate position(s)—often called prompts—introduced by <code>reset</code>, and even to resume control at the point at which we jumped afterwards. This in turn allows us to encode arbitrary effects and handlers.</p>
<p>In much the same way, the dual structure—probably a comonad—gives us local environments, sandboxing, and coeffects.</p>
<p>If <code>Cont r a</code> is ¬¬A, then what is this dual structure? Following the thread backwards, <code>Cont r a</code> is ¬¬A because <code>Cont r a</code> is (A → ⊥<sub>R</sub>) → ⊥<sub>R</sub>, which is an encoding of ¬¬A. Our encoding of 1<sub>E</sub> → A, on the other hand, doesn’t correspond to any connective—yet. So let’s introduce one: ¬̷, pronounced “not untrue,” is an <em>assertion</em> (some relation to the logical notion, no relation to the computational one), dual to a negation, and works just like our encoding above:</p>
<div class="connective">
<p><div class="rule left"> <div class="label">¬̷⊢</div> <div class="inference"> <div class="premise Γ">A, Γ</div> <div class="premise turnstile">⊢</div> <div class="premise Δ">Δ</div> <span class="line-of-inference"></span> <div class="conclusion Γ">¬̷A, Γ</div> <div class="conclusion turnstile">⊢</div> <div class="conclusion Δ">Δ</div> </div> </div> <div class="rule right"> <div class="inference"> <div class="premise Γ">Γ</div> <div class="premise turnstile">⊢</div> <div class="premise Δ">Δ, A</div> <span class="line-of-inference"></span> <div class="conclusion Γ">Γ</div> <div class="conclusion turnstile">⊢</div> <div class="conclusion Δ">Δ, ¬̷A</div> </div> <div class="label">⊢¬̷</div> </div></p>
</div>
<p>Unlike ¬, the composition of ¬̷ on itself is surprisingly boring. If ¬̷ encodes as 1 → A, then all we’ve got is 1 → 1 → A, which gives us nothing the single instance didn’t. I thought these things were supposed to be dual; what gives?</p>
<h2 id="polarization">Polarization</h2>
<p>I mentioned before that <code>sequoia</code> embeds <em>polarized</em> classical logic. Thus, the above tells only half the story, because we have two different negations: the negative negation ¬ (“not”), and the positive negation ~ (“negate”). They further accept propositions of the opposite polarity, i.e. ¬ takes a positive proposition and ~ takes a negative one, and are involutive, cancelling each other out. ¬~A<sup>-</sup> ≈ A<sup>-</sup>, and ~¬A<sup>+</sup> ≈ A<sup>+</sup>.</p>
<p>Likewise, there are actually two different assertions. ¬̷, which we saw above, is the negative one, while the positive one is stranger still. We arrived at the negative assertion by considering the negative negation, maybe we can find the positive one by a similar route.</p>
<p>The encoding of ¬A as A → ⊥ which we saw earlier wouldn’t be well-polarized for the positive negation ~A. Instead, ~A is encoded as 1 − A, where A − B (“A without B”) is (categorically) a coexponential, (logically) a coimplicaiton or subtraction, and (computationally) a calling context. (Downen has called it a call stack, but I dislike that name, as it’s more like a single frame than an entire stack.)</p>
<p>While the logical rules for its introduction and elimination offer some insight into what its representation must hold, it’s perhaps clearest under a different set of encodings: this time, encoding → and − in terms of disjunction/conjunction and negations. Classically, A → B can be encoded as ¬A ∨ B, while A − B can be encoded as A ∧ ¬B (i.e. “A and not B,” hence the pronunciation of − as “without”). If A − B could be encoded as a conjunction of A and the negation of B, then what does Curry-Howard have to say about that? Conjunctions are product types; negations are still continuations; A − B is isomorphic to a pair of an A and a continuation from B.</p>
<p>We can see now that A → B and A - B are dual: A − B holds both the argument to and continuation from A → B. I sometimes imagine A − B as a pipeline, with a section missing; A → B is precisely the missing section that fits and completes it.</p>
<p>Thus far our encodings of the two negations and our single assertion are:</p>
<ul>
<li>¬A ≈ A → ⊥</li>
<li>~A ≈ 1 - A</li>
<li>¬̷A = 1 → A</li>
</ul>
<p>We can further organize these by polarity and purpose:</p>
<table>
  <thead>
    <tr>
      <th>
      </th>
      <th>
        negative
      </th>
      <th>
        positive
      </th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <th>
        negation
      </th>
      <td>
        ¬A ≈ A → ⊥
      </td>
      <td>
        ~A ≈ 1 - A
      </td>
    </tr>
    <tr>
      <th>
        assertion
      </th>
      <td>
        ¬̷A = 1 → A
      </td>
      <td>
        …?
      </td>
    </tr>
  </tbody>
</table>
<p>The negations both invert polarity, whereas ¬̷ maintains it. Further, the negative connectives both employ →, whereas ~ uses −. Putting it together, we can expect the positive assertion to encode as −, and to maintain polarity, and that gives us:</p>
<table>
  <thead>
    <tr>
      <th>
      </th>
      <th>
        negative
      </th>
      <th>
        positive
      </th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <th>
        negation
      </th>
      <td>
        ¬A ≈ A → ⊥
      </td>
      <td>
        ~A ≈ 1 − A
      </td>
    </tr>
    <tr>
      <th>
        assertion
      </th>
      <td>
        ¬̷A = 1 → A
      </td>
      <td>
        ✓A ≈ A − ⊥
      </td>
    </tr>
  </tbody>
</table>
<p>✓, pronounced “true,” is truly dual to ¬, and ¬̷ is dual to ~. ✓’s encoding gives us the following rules:</p>
<div class="connective">
<p><div class="rule"> <div class="label">✓⊢</div> <div class="inference"> <div class="premise Γ">A, Γ</div> <div class="premise turnstile">⊢</div> <div class="premise Δ">Δ</div> <span class="line-of-inference"></span> <div class="conclusion Γ">✓A, Γ</div> <div class="conclusion turnstile">⊢</div> <div class="conclusion Δ">Δ</div> </div> </div> <div class="rule"> <div class="inference"> <div class="premise Γ">Γ</div> <div class="premise turnstile">⊢</div> <div class="premise Δ">Δ, A</div> <span class="line-of-inference"></span> <div class="conclusion Γ">Γ</div> <div class="conclusion turnstile">⊢</div> <div class="conclusion Δ">Δ, ✓A</div> </div> <div class="label">⊢✓</div> </div></p>
</div>
<p>So far, so… disappointing. These are precisely the same rules as we found for ¬̷; only the symbols and the polarities have been swapped. And what’s worse, the same was already true of the rules for the negations.</p>
<p>Speaking of which, the encoding for ~ seems circular: the positive continuation ~A can be encoded as 1 − A, itself represented as a pair of a unit value and … a continuation from A? But no, it’s the positive <em>negation</em> ~A that can be encoded thus. Just the same, that distinction alone isn’t satisfying: one wonders what the point of ~ is, polarity aside. We’ve already got a continuation connective in ¬; what do we need another one for?</p>
<p>It was in precisely such a mood that I happened to open Paul Downen &amp; Zena Ariola’s recent paper <em><a href="https://lmcs.episciences.org/6740">Compiling with Classical Connectives</a></em> to where I’d last left off, on a page starting with this paragraph:</p>
<figure>
  <blockquote cite="https://lmcs.episciences.org/6740"><p>The two negation types can be thought of as two dual way for representing first-class continuations in a programming language. One way to formulate a continuation is by capturing the context as a first class value. This corresponds to the data type ⊖A which packages up a covalue F as the value ⊖F, which can be later unpacked by pattern-matching in λ⊖α.c. Another way to formulate continuations is through functions that never return. This corresponds to the codata type ¬A which has values of the form λ¬x.c, which is analogous to a function abstraction that does not bind a return pointer, and covalues of the form ¬W, which is analogous to throwing a value to a continuation without waiting for a returned result.</p></blockquote>
  <figcaption><cite><a href="https://lmcs.episciences.org/6740">Compiling with Classical Connectives</a></cite>, Paul Downen, Zena M. Ariola</figcaption>
</figure>
<p>In short, you don’t use the same representation of continuations under two different names; you use two different representations, each with their own strengths. I was delighted to read this, because it reflects something about ~ that I’d only just noticed a day or two prior: the reason representing ¬A with continuations <code>a -&gt; r</code> <em>works</em> is that we’re consistent about it. Shouldn’t we be consistent about our treatment of 1, too? In which case, we should revisit our table:</p>
<table>
  <thead>
    <tr>
      <th>
      </th>
      <th>
        negative
      </th>
      <th>
        positive
      </th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <th>
        negation
      </th>
      <td>
        ¬A ≈ A → ⊥<sub>R</sub>
      </td>
      <td>
        ~A ≈ 1<sub>E</sub> - A
      </td>
    </tr>
    <tr>
      <th>
        assertion
      </th>
      <td>
        ¬̷A = 1<sub>E</sub> → A
      </td>
      <td>
        ✓A ≈ A - ⊥<sub>R</sub>
      </td>
    </tr>
  </tbody>
</table>
<p>In other words, ~A is defined to hold the environment in which it was constructed. It’s a lot like a closure, and precisely the kind of thing Downen &amp; Ariola describe.</p>
<p>This also sheds some light on the contrast between the two assertions. ✓A holds an A, along with a continuation from R. (I’m not exactly certain what that means, just yet.) ¬̷A, on the other hand, may close over an A, or it may <em>construct</em> one from E. In other words, ¬̷A models dynamically-scoped variables, and ✓A models lexically-scoped ones. And while ¬̷A may look partial at first blush, it‘s important to remember that while the logical rules don’t (currently) encode this fact, E needn’t be the same for every sequent any more than R need be. (<code>reset</code>, for example, allows the conclusion’s R to vary from the premise’s.)</p>
<h2 id="endings-and-beginnings">Endings and beginnings</h2>
<p>I set out to understand continuation-passing style better, and whatever its opposite might be, and ended up coming up with two new connectives modelling lexical &amp; dynamic scoping, a way to integrate coeffects with the same deep level of access as effects and CPS already enjoy, and a deeper appreciation the positive negation ~ and its role in contrast to ¬. Given all that, it’s hard to be too sad that I still don’t know much about what I was calling <a href="/posts/2021-07-08-environment-passing-style/">environment-passing style</a>. I intend to carry the even-handed treatment of ~ further still, and try to understand the encodings of → and −. I also intend to write about the modular, composable representation of n-input, n-output computations I’ve come up with based on the above findings. That will have to wait.</p>
<p>For now, I mostly just wanted to share how wonderful it is what sort of things we can discover as we follow the road back and forth across the Curry-Howard correspondence.</p>
<aside>
  <p>Thanks to Peter Murphy, <a href="https://twitter.com/ptrfrncsmrph/status/1420749056125685762">CSS Hero</a>, for help with the CSS for the sequent calculus rules.</p>
</aside>]]></summary>
</entry>
<entry>
    <title>Sequent Calculi and Metacircularity</title>
    <link href="https://antitypical.com/posts/2021-07-16-sequent-calculi-and-metacircularity/index.html" />
    <id>https://antitypical.com/posts/2021-07-16-sequent-calculi-and-metacircularity/index.html</id>
    <published>2021-07-16T16:06:12Z</published>
    <updated>2021-07-16T16:06:12Z</updated>
    <summary type="html"><![CDATA[<p>Sequent calculi are powerful and flexible tools for studying logic and, via Curry-Howard, computation. But why, and how? Where does this power come from?</p>
<!--more-->
<p>We enjoy a variety of idioms to describe the relationship between problems and solutions. For example: “use the right tool for the job,” and “a good impedance match.” Where sequent calculi offer a good impedance match, it may in part be because of how they model the logical primitives and principles we build atop them.</p>
<p>A sequent is, in general, a pair of contexts (collections of propositions), often represented by the variables Γ (the antecedents, or hypotheses; computationally, the inputs) and Δ (the succedents, or consequents; computationally, the outputs), separated by the ⊢ symbol (called “the turnstile”, but pronounced “proves,” “entails,” etc.; computationally, “produces,” “returns,” etc.), where Γ is treated conjunctively and Δ disjunctively. Thus, the general sequent form:</p>
<blockquote>
<p>Γ ⊢ Δ</p>
</blockquote>
<p>can be read as “all of Γ prove some of Δ,” or in computational terms, “all of Γ produce some of Δ.”</p>
<p>Specific configurations of sequent have more precise interpretations as a consequence of these general rules, and these give us examples of how we use the sequent calculus to build systems for logic and computation.</p>
<p>Starting simply, we have truth:</p>
<blockquote>
<p>· ⊢ A</p>
</blockquote>
<p>(NB: · on either side of the turnstile means an empty context.) Reading this literally, “nothing proves A,” but “nothing is required to prove A” or “A is provable without any extra information” are clearer. Or, simply, “A is true.” Dually, falsehood:</p>
<blockquote>
<p>A ⊢ ·</p>
</blockquote>
<p>Literally, “A proves nothing,” or “nothing is derivable from A;” more simply, “A is false.”</p>
<p>These two examples show us the edge cases of the two contexts: since we interpret Γ conjunctively, the empty case is truth; and since we interpret Δ disjunctively, the empty case is falsehood. The corner case, where both is empty, is interesting too:</p>
<blockquote>
<p>· ⊢ ·</p>
</blockquote>
<p>Interpreting as we did for truth and falsehood, “truth proves falsity”—a contradiction. This is a surprisingly useful tool to have logically, and perhaps even more so computationally, tho that will have to wait for a future post.</p>
<p>Truth and falsehood are the units of conjunction and disjunction, respectively, and since we treat the contexts in such manner it should be no surprise that we get those behaviours directly:</p>
<blockquote>
<p>A, B ⊢ ·</p>
</blockquote>
<p>Straightforwardly, “A and B are false.” Note the “and” there: conjunction! On the other side of the turnstile:</p>
<blockquote>
<p>· ⊢ A, B</p>
</blockquote>
<p>“A or B is true.” This is how we get disjunction.</p>
<p>This time, the opposite corner case isn’t much more interesting than the edges it intersects:</p>
<blockquote>
<p>A, B ⊢ C, D</p>
</blockquote>
<p>“A and B prove C or D” is a perfectly cromulent sequent to have kicking around, but we don’t learn a lot more from its treatment of the contexts. But observe that the turnstile plays a role here as well. It’s not <em>just</em> punctuation, or rather, it is, but the space it punctuates is important. “A proves B” is (more or less) another way of saying “A implies B,” and implication is the last piece missing. (Well, there’s negation, but you can compose that from the pieces we have so far.)</p>
<p>To recap, we’ve seen how to model ⊤ (truth), ⊥ (falsity), ∨ (disjunction), ∧ (conjunction), → (implication), and finally, contradiction. All of that just from examining individual sequents, not even considering how they’re composed together! Furthermore, you can make a case that the rules for how we treat occurrences of variables in sequents directly allow the encoding of universal and existential quantification.</p>
<p>This is perhaps my favourite example of metacircular interpretation; for another example, the ideal language to implement a lisp in turns out to be a lisp, because it’s already got everything a lisp needs.</p>]]></summary>
</entry>
<entry>
    <title>Environment-Passing Style</title>
    <link href="https://antitypical.com/posts/2021-07-08-environment-passing-style/index.html" />
    <id>https://antitypical.com/posts/2021-07-08-environment-passing-style/index.html</id>
    <published>2021-07-08T10:08:54Z</published>
    <updated>2021-07-08T10:08:54Z</updated>
    <summary type="html"><![CDATA[<p>Functions of type A → B can be translated into corresponding functions of type ¬B → ¬A in continuation-passing style (CPS), where ¬A is logically negation but computationally a continuation from A.</p>
<!--more-->
<p>This widens the view of functions as value transformers, taking values of type A to values of type B, to include an alternative perspective of them as continuation transformers (as noted by Andrzej Filinski in <em>Declarative Continuations and Categorical Duality</em>.)</p>
<p>Logic and computation are <a href="/posts/2021-06-07-duality/">rife with dualities</a>, leading one to wonder: what’s the dual of CPS?</p>
<p>Logically, ¬A is often regarded as equivalent to, or even synonymous with, A → ⊥. Computationally, ⊥ corresponds under Curry-Howard to the empty type (sometimes written 0; named <code>Void</code> in ghc Haskell). This is a perfectly reasonable choice when the entire program will be under this translation, but we often want only part of the program to undergo translation and thus a type more tractable than <code>Void</code> would be welcome.</p>
<p>Fortunately, it’s entirely acceptable to choose some <em>other</em> type to substitute for ⊥, so lng as we’re consistent. Somewhat arbitrarily, we’ll call R the result type. Now our CPS translation yields:</p>
<p>(B → R) → (A → R)</p>
<p>As a quick aside: this representation is just a flip away from being the composition of the <code>ReaderT</code> monad transformer on <code>ContT</code>.</p>
<p>As Filinski notes, functions-as-continuation-transformers map continuation contravariantly from the return type to the argument type. Otherwise put, applying a function f : A -&gt; B to a continuation k : ¬B (an operation which Filinski writes as k ↓ f) yields a continuation of type ¬A. Thinking of continuations as functions to some specially-chosen return type maks this look rather more like composition than application, but Filinski further stresses the importance of understanding continuations as their own kind of thing.</p>
<p>That said, it raises another question: why are continuations written with a type constructor, while values just sort of <em>are</em>? Why the asymmetry?</p>
<p>As noted before, ¬B → ¬A is equivalent to (B → ⊥) → (A → ⊥). One way to approach the question of duality is to dualize the logical propositions. We’re going to use the polarized logic from the previous post, but we won’t worry <em>too</em> much about the polarities, simply acknowledging that some quantity of shifts will be necessary.</p>
<p>Implication dualizes to subtraction: (A → B)<sup>⊥</sup> = A - B. Note that this is dual all by itself—A and B aren’t negated. So one answer could be: the dual of ¬B → ¬A is ¬B - ¬A. This is true; the latter represents precisely the negative space (as it were) around the former. But it’s somwhat unsatisfying just the same; that’s the dual of the function type, not the dual of CPS as a mechanism.</p>
<p>We can also negate the argument and return types, in which case the dual of ¬B → ¬A could be taken to be either B → A (classically) or ¬¬B → ¬¬A. And since A → B is equivalent to ¬B → ¬A, that means that we can further replace ¬¬B → ¬¬A with ¬¬¬A → ¬¬¬B, and then apply triple negation elimination (both classically and intuitionistically valid) to obtain (¬B → ¬A)<sup>⊥</sup> = ¬A → ¬B. Also true; also unsatisfying. What’s missing?</p>
<p>One of the great benefits of programmer-accessible CPS is the availability of delimited continuations, which are a generalization of regular, no-return continuations to return to one or more chosen places in a computation (typically in an outer scope). They furthermore allow the code there to return back into the inner scope, and thus enable inner scopes to communicate with outer ones—exactly what’s needed for effect handlers. ¬A <em>represents</em> a continuation from A, in that we interpret it as one, but if we want the dual of CPS we need to dualize continuations, too.</p>
<p>As one further bit of inspiration, just as ¬A, the negative negation of a positive proposition A, is equivalent to A → ⊥, ~A, the positive negation of a negative proposition A, is equivalent to 1 - A. The data of a subtraction consists of an argument on the left and a continuation from the proposition on the right—the argument to and continuation from the result of the dual function type, precisely—so using subtractions themselves would be moving the problem around, to some degree. But note that 1 and ⊥ are de Morgan duals; so clearly there’s something here.</p>
<p>Thus, modulo a bit of hand-waving, we arrive at:</p>
<p>((B → ⊥) → (A → ⊥))<sup>⊥</sup> = (1 → A) → (1 → B)</p>
<p>And just as we were justified in replacing ⊥ with R, we can now feel justified in replacing 1 with S, yielding:</p>
<p>((B → R) → (A → R))<sup>⊥</sup> = (S → A) → (S → B)</p>
<p>(The justification being that S abstracts 1 just as R abstracts ⊥.)</p>
<p>I’m describing this pattern of function as environment-passing style (tho I’m hoping someone has already described this in detail under a rather better name). I don’t have good idioms for its use, no handy APIs, nor best practices, but I am hopeful that it will prove useful in exploring the relationships between profunctor optics and CPS, and in describing a program’s context-awareness à la coeffects, just like continuations have done for effects. Programmable continuations have been marvellously handy; perhaps programmable values will be as well. And the composition(s) of the two styles is especially intruiging given that values and continuations can each wrap the other.</p>
<p>Finally, a vivid analogy keeps popping into my head, of a piece of twine or wire with 1 at one end and ⊥ at the other, and a program’s interpreter either pulling itself along generating values, or pushing itself along satisfying continuations. Good luck, little program.</p>]]></summary>
</entry>
<entry>
    <title>Duality</title>
    <link href="https://antitypical.com/posts/2021-06-07-duality/index.html" />
    <id>https://antitypical.com/posts/2021-06-07-duality/index.html</id>
    <published>2021-06-07T19:49:02Z</published>
    <updated>2021-06-07T19:49:02Z</updated>
    <summary type="html"><![CDATA[<p>The rules for a variety of polarized classical connectives, in a focused sequent calculus presentation to reflect a variety of dualities, and interpreted via Curry-Howard.</p>
<!--more-->
<h2 id="additive">Additive</h2>
<figure class="section">
  <div>
    <figure class="connective">
      <div class="column">
        <div class="rule">
          <div class="label">&amp;⊢<sub>1</sub></div>
          <div class="inference">
            <div class="premise Γ">[A<sup>−</sup>] Γ</div>
            <div class="premise turnstile">⊢</div>
            <div class="premise Δ">Δ</div>
            <span class="line-of-inference"></span>
            <div class="conclusion Γ">[A<sup>−</sup> &amp; B<sup>−</sup>] Γ</div>
            <div class="conclusion turnstile">⊢</div>
            <div class="conclusion Δ">Δ</div>
          </div>
        </div>
        <div class="rule">
          <div class="label">&amp;⊢<sub>2</sub></div>
          <div class="inference">
            <div class="premise Γ">[B<sup>−</sup>] Γ</div>
            <div class="premise turnstile">⊢</div>
            <div class="premise Δ">Δ</div>
            <span class="line-of-inference"></span>
            <div class="conclusion Γ">[A<sup>−</sup> &amp; B<sup>−</sup>] Γ</div>
            <div class="conclusion turnstile">⊢</div>
            <div class="conclusion Δ">Δ</div>
          </div>
        </div>
      </div>
      <div class="rule">
        <div class="inference">
          <div class="premises">
            <div class="premise">Γ ⊢ Δ, A<sup>−</sup></div>
            <div class="premise">Γ ⊢ Δ, B<sup>−</sup></div>
          </div>
          <span class="line-of-inference"></span>
          <div class="conclusion">Γ ⊢ Δ, A<sup>−</sup> &amp; B<sup>−</sup></div>
        </div>
        <div class="label">⊢&amp;</div>
      </div>
      <figcaption>
        &amp; (“with”): negative conjunction ≈ lazy pair
      </figcaption>
    </figure>
    <figure class="connective">
      <div class="rule">
        <div class="label">⊕⊢</div>
        <div class="inference">
          <div class="premises">
            <div class="premise">A<sup>+</sup>, Γ ⊢ Δ</div>
            <div class="premise">B<sup>+</sup>, Γ ⊢ Δ</div>
          </div>
          <span class="line-of-inference"></span>
          <div class="conclusion">A<sup>+</sup> ⊕ B<sup>+</sup>, Γ ⊢ Δ</div>
        </div>
      </div>
      <div class="column">
        <div class="rule">
          <div class="inference">
            <div class="premise Γ">Γ</div>
            <div class="premise turnstile">⊢</div>
            <div class="premise Δ">Δ [A<sup>+</sup>]</div>
            <span class="line-of-inference"></span>
            <div class="conclusion Γ">Γ</div>
            <div class="conclusion turnstile">⊢</div>
            <div class="conclusion Δ">Δ [A<sup>+</sup> ⊕ B<sup>+</sup>]</div>
          </div>
          <div class="label">⊢⊕<sub>1</sub></div>
        </div>
        <div class="rule">
          <div class="inference">
            <div class="premise Γ">Γ</div>
            <div class="premise turnstile">⊢</div>
            <div class="premise Δ">Δ [B<sup>+</sup>]</div>
            <span class="line-of-inference"></span>
            <div class="conclusion Γ">Γ</div>
            <div class="conclusion turnstile">⊢</div>
            <div class="conclusion Δ">Δ [A<sup>+</sup> ⊕ B<sup>+</sup>]</div>
          </div>
          <div class="label">⊢⊕<sub>2</sub></div>
        </div>
      </div>
      <figcaption>
        ⊕ (“sum”): positive disjunction ≈ either
      </figcaption>
    </figure>
    <div class="connective">
      <div class="rule">
        <p>~(A<sup>−</sup> &amp; B<sup>−</sup>) ≈ ~A<sup>−</sup> ⊕ ~B<sup>−</sup></p>
      </div>
      <div class="rule">
        <p>¬(A<sup>+</sup> ⊕ B<sup>+</sup>) ≈ ~A<sup>+</sup> &amp; ~B<sup>+</sup></p>
      </div>
    </div>
  </div>
  <figcaption>
    <p>The additive connectives, &amp; (pronounced “with”) and ⊕ (“sum”) are unfamiliar symbols for familiar connectives: &amp; is conjunction (∧, “and”), while ⊕ is disjunction (∨, “or”).</p>
    <p>&amp; is negative, and thus focused on the left (indicated by the square brackets). In a polarized calculus, negative connectives are defined by their left rules, which are rules for how to use them. (Γ contains inputs, so left rules consume things.) &amp; has two left rules, which use it by projecting out the left and right parts, respectively. Its right rule builds it from its components: think pair/tuple literals.</p>
    <p>⊕ is positive, and thus focused on the right. Positive connectives are defined by their right rules, which are rules for how to make them. (Δ contains outputs, so right rules produce things.) Its left rule consumes the sum by handling each alternative separately; think <code>case</code> expressions over an <code>Either</code>.</p>
  </figcaption>
</figure>
<figure class="section">
  <figcaption>
    <p>The additive units, ⊤ (“top”) and 0, are a bit of a puzzle. Note that neither has a focusing rule: you can’t use a ⊤ once you have it, and you can’t get a 0 at all. On the other hand, both their invertible rules are axioms (i.e. have no premises).</p>
    <p>A sequent Γ ⊢ Δ can be read as “all of Γ prove any of Δ;” under that interpretation we can see that ⊤, which corresponds to logical truth, indeed satisfies that claim: once at least one thing on the right is proven, we’re done.</p>
    <p>Likewise, the left rule for 0, falsity, is recognizable as the principle of <em>ex falso quodlibet</em>: you can prove anything at all from a contradiction.</p>
  </figcaption>
  <div>
    <figure class="connective">
      <div class="rule">
        <p>no rule for ⊤⊢</p>
      </div>
      <div class="rule">
        <div class="inference">
          <div class="axiom"></div>
          <span class="line-of-inference"></span>
          <div class="conclusion">Γ ⊢ Δ, ⊤</div>
        </div>
        <div class="label">⊢⊤</div>
      </div>
      <figcaption>
        ⊤ (“top”): negative truth ≈ unit
      </figcaption>
    </figure>
    <figure class="connective">
      <div class="rule">
        <div class="label">0⊢</div>
        <div class="inference">
          <div class="axiom"></div>
          <span class="line-of-inference"></span>
          <div class="conclusion">0, Γ ⊢ Δ</div>
        </div>
      </div>
      <div class="rule">
        <p>no rule for ⊢0</p>
      </div>
      <figcaption>
        0: positive falsity ≈ void
      </figcaption>
    </figure>
    <div class="connective">
      <div class="rule">
        <p>~⊤ ≈ 0</p>
      </div>
      <div class="rule">
        <p>¬0 ≈ ⊤</p>
      </div>
    </div>
  </div>
</figure>
<h2 id="multiplicative">Multiplicative</h2>
<figure class="section">
  <div>
    <figure class="connective">
      <div class="rule">
        <div class="label">⅋⊢</div>
        <div class="inference">
          <div class="premises">
            <div class="premise">[A<sup>−</sup>] Γ ⊢ Δ</div>
            <div class="premise">[B<sup>−</sup>] Γ ⊢ Δ</div>
          </div>
          <span class="line-of-inference"></span>
          <div class="conclusion">[A<sup>−</sup> ⅋ B<sup>−</sup>] Γ ⊢ Δ</div>
        </div>
      </div>
      <div class="rule">
        <div class="inference">
          <div class="premise Γ">Γ</div>
          <div class="premise turnstile">⊢</div>
          <div class="premise Δ">Δ, A<sup>−</sup>, B<sup>−</sup></div>
          <span class="line-of-inference"></span>
          <div class="conclusion Γ">Γ</div>
          <div class="conclusion turnstile">⊢</div>
          <div class="conclusion Δ">Δ, A<sup>−</sup> ⅋ B<sup>−</sup></div>
        </div>
        <div class="label">⊢⅋</div>
      </div>
      <figcaption>
        ⅋ (“par”): negative disjunction ≈ parallel/nondeterministic choice
      </figcaption>
    </figure>
    <figure class="connective">
      <div class="rule">
        <div class="label">⊗⊢</div>
        <div class="inference">
          <div class="premise Γ">A<sup>+</sup>, B<sup>+</sup>, Γ</div>
          <div class="premise turnstile">⊢</div>
          <div class="premise Δ">Δ</div>
          <span class="line-of-inference"></span>
          <div class="conclusion Γ">A<sup>+</sup> ⊗ B<sup>+</sup>, Γ</div>
          <div class="conclusion turnstile">⊢</div>
          <div class="conclusion Δ">Δ</div>
        </div>
      </div>
      <div class="rule">
        <div class="inference">
          <div class="premises">
            <div class="premise">Γ ⊢ Δ [A<sup>+</sup>]</div>
            <div class="premise">Γ ⊢ Δ [B<sup>+</sup>]</div>
          </div>
          <span class="line-of-inference"></span>
          <div class="conclusion">Γ ⊢ Δ [A<sup>+</sup> ⊗ B<sup>+</sup>]</div>
        </div>
        <div class="label">⊢⊗</div>
      </div>
      <figcaption>
        ⊗ (“tensor”): positive conjunction ≈ strict pair
      </figcaption>
    </figure>
    <div class="connective">
      <div class="rule">
        <p>~(A<sup>−</sup> ⅋ B<sup>−</sup>) ≈ ~A<sup>−</sup> ⊗ ~B<sup>−</sup></p>
      </div>
      <div class="rule">
        <p>¬(A<sup>+</sup> ⊗ B<sup>+</sup>) ≈ ~A<sup>+</sup> ⅋ ~B<sup>+</sup></p>
      </div>
    </div>
  </div>
  <figcaption>
    <p>In addition to &amp; and ⊕, the <em>additive</em> conjunction and disjunction, ⅋ (“par”) and ⊗ (“tensor”) are <em>multiplicative</em> disjunction and conjunction. The difference is more obvious in a linear logic, but for us the relevant distinction between &amp; and ⊗ is that we identify negative (resp. positive) types like &amp; (resp. ⊗) with call-by-name (resp. call-by-value).</p>
    <p>⅋, however, is stranger. It’s a disjunction, eliminated by using both halves (just like ⊕), but introduced using <em>two</em> things. Linear logic again offers one perspective, but another reading of Γ ⊢ Δ (via Curry-Howard) as “consume Γ to produce Δ” is salient: parallelism (hence “par”), or nondeterminism. The latter explains why ⅋ is disjunctive despite (at least notionally) containing two things; think of <code>&lt;|&gt;</code>. For <code>Maybe</code>, it selects the leftmost <code>Just</code>, acting as a choice; for <code>[]</code>, it instead selects <em>all</em> alternatives, acting as a union.</p>
  </figcaption>
</figure>
<figure class="section">
  <figcaption>
    <p>Alongside multiplicative disjunction and conjunction are ⊥ (“bottom”), a negative falsity, and 1, a positive truth.</p>
    <p>⊥, like positive falsity (0), proves anything if you’ve already got one (⊥⊢). Surprisingly, we can introduce one when we can prove the rest of the sequent (⊢⊥). Logically, falsity can’t change Δ’s provability, so this rule is justified.</p>
    <p>Dually, we can’t learn anything from vacuous truth, so 1 can be eliminated freely (1⊢). Introducing it is likewise trivial (⊢1), just as for ⊤.</p>
  </figcaption>
  <div>
    <figure class="connective">
      <div class="rule">
        <div class="label">⊥⊢</div>
        <div class="inference">
          <div class="axiom"></div>
          <span class="line-of-inference"></span>
          <div class="conclusion">[⊥] Γ ⊢ Δ</div>
        </div>
      </div>
      <div class="rule">
        <div class="inference">
          <div class="premise Γ">Γ</div>
          <div class="premise turnstile">⊢</div>
          <div class="premise Δ">Δ</div>
          <span class="line-of-inference"></span>
          <div class="conclusion Γ">Γ</div>
          <div class="conclusion turnstile">⊢</div>
          <div class="conclusion Δ">Δ, ⊥</div>
        </div>
        <div class="label">⊢⊥</div>
      </div>
      <figcaption>
        ⊥ (“bottom”): negative falsity ≈ void
      </figcaption>
    </figure>
    <figure class="connective">
      <div class="rule">
        <div class="label">1⊢</div>
        <div class="inference">
          <div class="premise Γ">Γ</div>
          <div class="premise turnstile">⊢</div>
          <div class="premise Δ">Δ</div>
          <span class="line-of-inference"></span>
          <div class="conclusion Γ">1, Γ</div>
          <div class="conclusion turnstile">⊢</div>
          <div class="conclusion Δ">Δ</div>
        </div>
      </div>
      <div class="rule">
        <div class="inference">
          <div class="axiom"></div>
          <span class="line-of-inference"></span>
          <div class="conclusion">Γ ⊢ Δ [1]</div>
        </div>
        <div class="label">⊢1</div>
      </div>
      <figcaption>
        1: positive truth ≈ unit
      </figcaption>
    </figure>
    <div class="connective">
      <div class="rule">
        <p>~⊥ ≈ 1</p>
      </div>
      <div class="rule">
        <p>¬1 ≈ ⊥</p>
      </div>
    </div>
  </div>
</figure>
<h2 id="implicative">Implicative</h2>
<figure class="section">
  <div>
    <figure class="connective">
      <div class="rule">
        <div class="label">→⊢</div>
        <div class="inference">
          <div class="premises">
            <div class="premise">Γ ⊢ Δ [A<sup>+</sup>]</div>
            <div class="premise">[B<sup>−</sup>] Γ ⊢ Δ</div>
          </div>
          <span class="line-of-inference"></span>
          <div class="conclusion">[A<sup>+</sup> → B<sup>−</sup>] Γ ⊢ Δ</div>
        </div>
      </div>
      <div class="rule">
        <div class="inference">
          <div class="premise Γ">A<sup>+</sup>, Γ</div>
          <div class="premise turnstile">⊢</div>
          <div class="premise Δ">Δ, B<sup>−</sup></div>
          <span class="line-of-inference"></span>
          <div class="conclusion Γ">Γ</div>
          <div class="conclusion turnstile">⊢</div>
          <div class="conclusion Δ">Δ, A<sup>+</sup> → B<sup>−</sup></div>
        </div>
        <div class="label">⊢→</div>
      </div>
      <figcaption>
        →: negative implication ≈ function
      </figcaption>
    </figure>
    <figure class="connective">
      <div class="rule">
        <div class="label">–⊢</div>
        <div class="inference">
          <div class="premise Γ">A<sup>+</sup>, Γ</div>
          <div class="premise turnstile">⊢</div>
          <div class="premise Δ">Δ, B<sup>−</sup></div>
          <span class="line-of-inference"></span>
          <div class="conclusion Γ">A<sup>+</sup> – B<sup>−</sup>, Γ</div>
          <div class="conclusion turnstile">⊢</div>
          <div class="conclusion Δ">Δ</div>
        </div>
      </div>
      <div class="rule">
        <div class="inference">
          <div class="premises">
            <div class="premise">Γ ⊢ Δ [A<sup>+</sup>]</div>
            <div class="premise">[B<sup>−</sup>] Γ ⊢ Δ</div>
          </div>
          <span class="line-of-inference"></span>
          <div class="conclusion">Γ ⊢ Δ [A<sup>+</sup> – B<sup>−</sup>]</div>
        </div>
        <div class="label">⊢–</div>
      </div>
      <figcaption>
        – (“subtraction”, sometimes ⤙, “co-implication”): positive implication ≈ calling context
      </figcaption>
    </figure>
    <div class="connective">
      <div class="rule">
        <p>~(A<sup>+</sup> → B<sup>−</sup>) ≈ A<sup>+</sup> – B<sup>−</sup></p>
      </div>
      <div class="rule">
        <p>¬(A<sup>+</sup> – B<sup>−</sup>) ≈ A<sup>+</sup> → B<sup>−</sup></p>
      </div>
    </div>
  </div>
  <figcaption>
    <p>Just as implication resembles the turnstile (as is evident in the premise of ⊢→), our computational reading of Γ ⊢ Δ as “consume Γ to produce Δ” indicates that functions do as well.</p>
    <p>A – B can be read as “A without B” (both arithmetically and logically), but insight into its computational interpretation can be gained by its relationship to functions.</p>
    <p>The premises for →⊢ and ⊢– are the same, as are the ones for ⊢→ and –⊢: duality <em>means</em> “each eliminates the other.” → eliminations are function calls, so – has an argument: the A in the first premise of ⊢–. B is a hypothesis, meaning that the derivation must <em>provide</em> it. Therefore, it also has a <em>continuation from B</em>—and thus, everything you need to call a function: both input, and output destination.</p>
    <p>This gives a vivid picture of the nature of duality: a subtraction is the negative space around an implication, and an implication is therefore also the negative space around a subtraction. A complete view of either requires both.</p>
  </figcaption>
</figure>
<h2 id="negating">Negating</h2>
<figure class="section">
  <figcaption>
    <p>Like → and –, negations have the interesting behaviour of moving propositions across the turnstile: from antecedents to succeedents. They are constructed (⊢¬ and ⊢~) from a premise with a hypothesis: to make a ¬A or ~A, we must have a premise which uses an A—rather like the premise of ⊢→. Dually, their elimination (¬⊢ and ~⊢) requires an A to use as input. Thus, negations have long been given computational meaning as <em>continuations</em>, a representation of “the rest of the program” from some program point.</p>
    <p>Intuitionistic logics therefore often encode negation as implication of falsity, i.e. ¬A ≈ A → ⊥. Intuitively, “not A” and “A implies falsity” align. This has the precise shape of a continuation. Further, double-negation like ¬¬A becomes (A → ⊥) → ⊥, which has the shape of continuation-passing style.</p>
    <p>Our negations are <em>involutive</em>, i.e. (mutual) self-inverses, due both to polarization (flipped from their argument) and focusing behaviour (remaining in the current phase).</p>
  </figcaption>
  <div>
    <figure class="connective">
      <div class="rule">
        <div class="label">¬⊢</div>
        <div class="inference">
          <div class="premise Γ">Γ</div>
          <div class="premise turnstile">⊢</div>
          <div class="premise Δ">Δ [A<sup>+</sup>]</div>
          <span class="line-of-inference"></span>
          <div class="conclusion Γ">[¬A<sup>+</sup>] Γ</div>
          <div class="conclusion turnstile">⊢</div>
          <div class="conclusion Δ">Δ</div>
        </div>
      </div>
      <div class="rule">
        <div class="inference">
          <div class="premise Γ">A<sup>+</sup>, Γ</div>
          <div class="premise turnstile">⊢</div>
          <div class="premise Δ">Δ</div>
          <span class="line-of-inference"></span>
          <div class="conclusion Γ">Γ</div>
          <div class="conclusion turnstile">⊢</div>
          <div class="conclusion Δ">Δ, ¬A<sup>+</sup></div>
        </div>
        <div class="label">⊢¬</div>
      </div>
      <figcaption>
        ¬ (“not”): positive-within-negative negation ≈ lazy continuation
      </figcaption>
    </figure>
    <figure class="connective">
      <div class="rule">
        <div class="label">~⊢</div>
        <div class="inference">
          <div class="premise Γ">Γ</div>
          <div class="premise turnstile">⊢</div>
          <div class="premise Δ">Δ, A<sup>−</sup></div>
          <span class="line-of-inference"></span>
          <div class="conclusion Γ">~A<sup>−</sup>, Γ</div>
          <div class="conclusion turnstile">⊢</div>
          <div class="conclusion Δ">Δ</div>
        </div>
      </div>
      <div class="rule">
        <div class="inference">
          <div class="premise Γ">[A<sup>−</sup>] Γ</div>
          <div class="premise turnstile">⊢</div>
          <div class="premise Δ">Δ</div>
          <span class="line-of-inference"></span>
          <div class="conclusion Γ">Γ</div>
          <div class="conclusion turnstile">⊢</div>
          <div class="conclusion Δ">Δ [~A<sup>−</sup>]</div>
        </div>
        <div class="label">⊢~</div>
      </div>
      <figcaption>
        ~ (“negate”): negative-within-positive negation ≈ strict continuation
      </figcaption>
    </figure>
    <div class="connective">
      <div class="rule">
        <p>~¬A<sup>+</sup> ≈ A<sup>+</sup></p>
      </div>
      <div class="rule">
        <p>¬~A<sup>−</sup> ≈ A<sup>−</sup></p>
      </div>
    </div>
  </div>
</figure>
<h2 id="shifts">Shifts</h2>
<figure class="section">
  <div>
    <figure class="connective">
      <div class="rule">
        <div class="label">↑⊢</div>
        <div class="inference">
          <div class="premise Γ">A<sup>+</sup>, Γ</div>
          <div class="premise turnstile">⊢</div>
          <div class="premise Δ">Δ</div>
          <span class="line-of-inference"></span>
          <div class="conclusion Γ">[↑A<sup>+</sup>] Γ</div>
          <div class="conclusion turnstile">⊢</div>
          <div class="conclusion Δ">Δ</div>
        </div>
      </div>
      <div class="rule">
        <div class="inference">
          <div class="premise Γ">Γ</div>
          <div class="premise turnstile">⊢</div>
          <div class="premise Δ">Δ, A<sup>+</sup></div>
          <span class="line-of-inference"></span>
          <div class="conclusion Γ">Γ</div>
          <div class="conclusion turnstile">⊢</div>
          <div class="conclusion Δ">Δ, ↑A<sup>+</sup></div>
        </div>
        <div class="label">⊢↑</div>
      </div>
      <figcaption>
        ↑ (“up shift,” call-by-push-value’s <em>F</em>): positive-within-negative shift ≈ return
      </figcaption>
    </figure>
    <figure class="connective">
      <div class="rule">
        <div class="label">↓⊢</div>
        <div class="inference">
          <div class="premise Γ">A<sup>−</sup>, Γ</div>
          <div class="premise turnstile">⊢</div>
          <div class="premise Δ">Δ</div>
          <span class="line-of-inference"></span>
          <div class="conclusion Γ">↓A<sup>−</sup>, Γ</div>
          <div class="conclusion turnstile">⊢</div>
          <div class="conclusion Δ">Δ</div>
        </div>
      </div>
      <div class="rule">
        <div class="inference">
          <div class="premise Γ">Γ</div>
          <div class="premise turnstile">⊢</div>
          <div class="premise Δ">Δ, A<sup>−</sup></div>
          <span class="line-of-inference"></span>
          <div class="conclusion Γ">Γ</div>
          <div class="conclusion turnstile">⊢</div>
          <div class="conclusion Δ">Δ [↓A<sup>−</sup>]</div>
        </div>
        <div class="label">⊢↓</div>
      </div>
      <figcaption>
        ↓ (“down shift”, call-by-push-value’s <em>U</em>): negative-within-positive shift ≈ thunk
      </figcaption>
    </figure>
    <figure class="connective">
      <div class="rule">
        <p>(A → B)<sup>N</sup> = ↓(A<sup>N</sup>) → B</p>
      </div>
      <div class="rule">
        <p>(A → B)<sup>V</sup> = ↓(A<sup>V</sup> → ↑(B<sup>V</sup>))</p>
      </div>
      <figcaption>
        translations of CBN and CBV function types into polarized calculi
      </figcaption>
    </figure>
  </div>
  <figcaption>
    <p>Shifts serve two pragmatic purposes: like negations, they have the opposite polarity of whatever they shift; and they end the focusing phase of proof search and begin the inversion phase.</p>
    <p>Up shifts may be unfamiliar in terms of types, but at the term level are something like a <code>return</code>, particularly in monadic code: they embed a value (positive) within a computation (negative). In CBPV (call-by-push-value), this is the left adjoint, F.</p>
    <p>Down shifts, meanwhile, may be more familiar as thunks: they wrap a computation (negative) up into a value (positive). In CBPV, this is the right adjoint, U.</p>
    <p>The translations of function types from CBN and CBV into polarized calculi (left) model evaluation orders using shifts. The CBN translation treats arguments as thunks around lazy computations, while the CBV translation explicitly wraps the result in a computation.</p>
  </figcaption>
</figure>
<h2 id="quantifiers">Quantifiers</h2>
<figure class="section">
  <figcaption>
    <p>The rules for quantification are slightly unusual in this presentation in their use of both side conditions (checking that the variable does not occur free elsewhere within the sequent) and (capture-avoiding) substitution (A{B/X} substitutes the proposition B for the variable X within A, e.g. (X ⊕ Y){Z/X} = Z ⊕ Y).</p>
    <p>Quantified propositions—and thus, types—offer yet more dualities: both can be used to hide information, but from different perspectives. ∀ constrains its construction, but is used freely; ∃ constrains its uses, but is constructed freely. Universally-quantified types are used when folding polymorphically recursive data and a variety of encodings using functions. Existentials model abstraction in abstract data types, ML modules, open universes of exceptions, and GADTs.</p>
    <p>Here, the identification of negative = computation, positive = value is stretched. If computation in the CBPV sense is “something resident in code pages” then ∀ seems misplaced—why should ∀ be represented at runtime (absent dependent types)? On the other hand, the identification of positive = data, negative = codata fits: ∀ is defined by how it is used, and ∃ by how it is made.</p>
  </figcaption>
  <div>
    <figure class="connective">
      <div class="rule">
        <div class="label">∀⊢</div>
        <div class="inference">
          <div class="premise Γ">[A<sup>−</sup>{B/X}] Γ</div>
          <div class="premise turnstile">⊢</div>
          <div class="premise Δ">Δ</div>
          <span class="line-of-inference"></span>
          <div class="conclusion Γ">[∀X.A<sup>−</sup>] Γ</div>
          <div class="conclusion turnstile">⊢</div>
          <div class="conclusion Δ">Δ</div>
        </div>
      </div>
      <div class="rule">
        <div class="inference">
          <div class="premise Γ">Γ</div>
          <div class="premise turnstile">⊢</div>
          <div class="premise Δ">Δ, A<sup>−</sup></div>
          <div class="side-condition">X ∉ <span class="function">fv</span>(Γ ⊢ Δ)</div>
          <span class="line-of-inference"></span>
          <div class="conclusion Γ">Γ</div>
          <div class="conclusion turnstile">⊢</div>
          <div class="conclusion Δ">Δ, ∀X.A<sup>−</sup></div>
        </div>
        <div class="label">⊢∀</div>
      </div>
      <figcaption>
        ∀ (“for all”): universal quantification ≈ polymorphism
      </figcaption>
    </figure>
    <figure class="connective">
      <div class="rule">
        <div class="label">∃⊢</div>
        <div class="inference">
          <div class="premise Γ">A<sup>+</sup>, Γ</div>
          <div class="premise turnstile">⊢</div>
          <div class="premise Δ">Δ</div>
          <span class="line-of-inference"></span>
          <div class="conclusion Γ">∃A<sup>+</sup>, Γ</div>
          <div class="conclusion turnstile">⊢</div>
          <div class="conclusion Δ">Δ</div>
        </div>
      </div>
      <div class="rule">
        <div class="inference">
          <div class="premise Γ">Γ</div>
          <div class="premise turnstile">⊢</div>
          <div class="premise Δ">Δ, A<sup>+</sup></div>
          <span class="line-of-inference"></span>
          <div class="conclusion Γ">Γ</div>
          <div class="conclusion turnstile">⊢</div>
          <div class="conclusion Δ">Δ [∃A<sup>+</sup>]</div>
        </div>
        <div class="label">⊢∃</div>
      </div>
      <figcaption>
        ∃ (“there exists”): existential quantification ≈ abstract data type
      </figcaption>
    </figure>
    <div class="connective">
      <div class="rule">
        <p>~(∀X.A<sup>−</sup>) ≈ ∃X.~A<sup>−</sup></p>
      </div>
      <div class="rule">
        <p>¬(∃X.A<sup>+</sup>) ≈ ∀X.¬A<sup>+</sup></p>
      </div>
    </div>
  </div>
</figure>
<h2 id="core">Core</h2>
<figure class="section">
  <div class="column">
    <div class="rule">
      <div class="inference">
        <div class="axiom"></div>
        <span class="line-of-inference"></span>
        <div class="conclusion Γ">A</div>
        <div class="conclusion turnstile">⊢</div>
        <div class="conclusion Δ">A</div>
      </div>
      <div class="label"><span class="function">init</span></div>
    </div>
    <div class="rule">
      <div class="inference">
        <div class="premises">
          <div class="premise">Γ ⊢ Δ, A</div>
          <div class="premise">A, Γ ⊢ Δ</div>
        </div>
        <span class="line-of-inference"></span>
        <div class="conclusion">Γ ⊢ Δ</div>
      </div>
      <div class="label"><span class="function">cut</span></div>
    </div>
  </div>
  <figcaption>
    <p>The init and cut rules are quite common to sequent (and other) calculi. This presentation clarifies a couple of useful properties.</p>
    <p>init allows us to begin a proof (or end one, working bottom-up as we often do, from goal to premise) with a proposition given to us. Under Curry-Howard’s interpretation of proofs as programs, we can understand this as the polymorphic identity function, <code>id</code>. (Sequent calculus proofs in particular correspond to higher-order programs, e.g. functions taking functions to functions.)</p>
    <p>cut instead allows us to prove a sequent by introducing and immediately eliminating a proposition in its premises. Again taking sequents as analogues of function types, we can think of it as the <em>composition</em> of proofs with compatible consequents and hypotheses.</p>
    <p>Furthermore, cut and init form a category, where the morphisms are sequents between contexts, joined by cuts. The Curry-Howard correspondence holds up here, too: <code>id</code> and function composition give a category of functions between types.</p>
  </figcaption>
</figure>
<h2 id="structural">Structural</h2>
<figure class="section">
  <figcaption>
    <p>Structural rules governing our use of the context. Without these, our logic would be classical <em>linear</em> logic (and would have to adjust the multiplicative and cut rules to split the context between premises). The rules are given their traditional names here, but since we mostly operate bottom-up, starting with the goal given by the syntax of a program, they actually have the exact opposite sense for us.</p>
    <p>Top-down, weaken introduces an arbitrary hypothesis or consequent. An extra hypothesis weakens the proof because more information must be provided to prove the same conclusion. An extra conclusion instead weakens what we can learn from it. Contraction, meanwhile, eliminates redundant information from the context.</p>
    <p>Bottom-up, weakening instead <em>strengthens</em> a premise, tightening its requirements and guarantees. In reality, however, this mostly amounts to bookkeeping, removing propositions that are in the way of some goal. Contraction, meanwhile, allows us to duplicate information we already know, again primarily as a way of getting one’s ducks in a row for the benefit of proof search. e.g. init proves a minimalistic A ⊢ A. Weakening is often required to whittle sequents down for init to apply.</p>
    <p>Note that the customary exchange rule is not required as this presentation’s contexts are unordered.</p>
  </figcaption>
  <div>
    <div class="connective">
      <div class="rule">
        <div class="label"><span class="function">weaken</span> ⊢</div>
        <div class="inference">
          <div class="premise Γ">Γ</div>
          <div class="premise turnstile">⊢</div>
          <div class="premise Δ">Δ</div>
          <span class="line-of-inference"></span>
          <div class="conclusion Γ">A, Γ</div>
          <div class="conclusion turnstile">⊢</div>
          <div class="conclusion Δ">Δ</div>
        </div>
      </div>
      <div class="rule">
        <div class="inference">
          <div class="premise Γ">Γ</div>
          <div class="premise turnstile">⊢</div>
          <div class="premise Δ">Δ</div>
          <span class="line-of-inference"></span>
          <div class="conclusion Γ">Γ</div>
          <div class="conclusion turnstile">⊢</div>
          <div class="conclusion Δ">Δ, A</div>
        </div>
        <div class="label">⊢ <span class="function">weaken</span></div>
      </div>
    </div>
    <div class="connective">
      <div class="rule">
        <div class="label"><span class="function">contract</span> ⊢</div>
        <div class="inference">
          <div class="premise Γ">A, A, Γ</div>
          <div class="premise turnstile">⊢</div>
          <div class="premise Δ">Δ</div>
          <span class="line-of-inference"></span>
          <div class="conclusion Γ">A, Γ</div>
          <div class="conclusion turnstile">⊢</div>
          <div class="conclusion Δ">Δ</div>
        </div>
      </div>
      <div class="rule">
        <div class="inference">
          <div class="premise Γ">Γ</div>
          <div class="premise turnstile">⊢</div>
          <div class="premise Δ">Δ, A, A</div>
          <span class="line-of-inference"></span>
          <div class="conclusion Γ">Γ</div>
          <div class="conclusion turnstile">⊢</div>
          <div class="conclusion Δ">Δ, A</div>
        </div>
        <div class="label">⊢ <span class="function">contract</span></div>
      </div>
    </div>
  </div>
</figure>]]></summary>
</entry>
<entry>
    <title>All you need is λ, part one: booleans</title>
    <link href="https://antitypical.com/posts/2020-03-29-all-you-need-is-lambda-1-booleans/index.html" />
    <id>https://antitypical.com/posts/2020-03-29-all-you-need-is-lambda-1-booleans/index.html</id>
    <published>2020-03-29T20:17:26Z</published>
    <updated>2020-03-29T20:17:26Z</updated>
    <summary type="html"><![CDATA[<p>Nearly a century ago, Alonzo Church invented the simple, elegant, and yet elusive lambda calculus. Along with Alan Turing, he then proved the Church-Turing thesis: that anything computable with a Turing machine can also be computed in the lambda calculus. However, nearly as soon as we had digital computers, we started inventing programming languages, and with them a vast treasure of features, beautiful and terrible, many of which seem very hard to relate to the fundamental nature of computability, let alone the lambda calculus specifically.</p>
<!--more-->
<p>While it’s true that anything which can be computed, period, can be computed in the lambda calculus, you might not want to: it’s austere, to say the least, and was not designed with modern sensibilities regarding readability in mind. We developed all those languages and features for a reason! Still, Church demonstrated not just that it was possible to compute anything computable with the lambda calculus, but also <em>how</em> one might do so.</p>
<p>In this series, we’ll examine some ways to express common programming language features using the minimalistic tools of the lambda calculus. We begin with perhaps the most ubiquitous type: booleans.</p>
<h2 id="λ-is-blind">λ is blind</h2>
<p>The lambda calculus’s austerity is extreme: you don’t even have booleans. All you have are:</p>
<ol type="1">
<li><p>Lambda abstractions;</p></li>
<li><p>Applications; and</p></li>
<li><p>Variables.</p></li>
</ol>
<p>We’ll now review these in some detail; feel free to skip this section if you’re already familiar with the lambda calculus.</p>
<h3 id="lambda-abstractions">Lambda abstractions</h3>
<p>Lambda abstractions (“lambdas,” “abstractions,” and “functions” will also be used interchangeably) introduce a function of a single variable.</p>
<p>Abstractions are written <code>λ x . y</code>, for variable <code>x</code> and expression <code>y</code>, where <code>x</code> is now available as a bound variable in the body, and any enclosing definition of <code>x</code> is shadowed (i.e. <code>λ x . λ x . x</code> = <code>λ x . λ y . y</code> ≠ <code>λ x . λ y . x</code>). (We shall assume strictly lexical scoping for the time being.)</p>
<p>In Haskell, we would write <code>\ x -&gt; y</code> instead; in JavaScript, <code>function (x) { return y }</code> or <code>(x) =&gt; y</code>.</p>
<h3 id="applications">Applications</h3>
<p>Applications (“function application” and “function call” will be used interchangeably) apply the result of the expression on the left to the expression on the right.</p>
<p>Applications are written as <code>x y</code>, for expressions x and y, and left-associated, i.e. <code>a b c</code> = <code>(a b) c</code> ≠ <code>a (b c)</code>. Function application binds tighter than lambda abstraction, i.e. <code>λ x . λ y . y x</code> = <code>λ x . λ y . (y x)</code> ≠ <code>λ x . (λ y . y) x</code>.</p>
<p>The syntax is the same in Haskell; in JavaScript, we would write <code>x(y)</code> or <code>a(b, c)</code>. Note however that since lambda calculus functions are all single-argument functions, a more direct (though less idiomatic) equivalent for the latter would be <code>a(b)(c)</code>.</p>
<h3 id="variables">Variables</h3>
<p>Variables introduced by enclosing lambdas.</p>
<p>Variable are written as more or less arbitrary names, typically alphanumeric (e.g. <code>x</code> or <code>y0</code> or <code>thing</code>); however, we will feel free to include non-alphanumeric characters in names as we see fit, since the paucity of syntax means there’s little risk of ambiguity.</p>
<p>Since the only available variables are those bound by enclosing lambdas, we can also infer that there are no <code>let</code> bindings for local variables, and no globals of any sort; the lambda calculus doesn’t come with a standard library.</p>
<h3 id="summary">Summary</h3>
<p>In quasi-BNF, the grammar for the lambda calculus is extremely minimal:</p>
<figure class="center">

_e_ **:=** `λ` _x_ `.` _e_ **|** _e_ _e_ **|** _x_ **|** (_e_)

</figure>
<p>And finally, this table gives a side-by-side comparison of the syntax of the lambda calculus with the corresponding syntax in Haskell &amp; JavaScript:</p>
<table>
  <caption>Syntax of the lambda calculus, Haskell, & JavaScript</caption>
  <thead>
    <tr>
      <th scope="col"></th>
      <th scope="col">Lambda calculus</th>
      <th scope="col">Haskell</th>
      <th scope="col">JavaScript</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <th scope="row">Abstraction</th>
      <td><code>λ x . y</code></td>
      <td><code>\\ x -> y</code></td>
      <td><code>(x) => y</code></td>
    </tr>
    <tr>
      <th scope="row">Application</th>
      <td><code>f x</code></td>
      <td><code>f x</code></td>
      <td><code>f(x)</code></td>
    </tr>
    <tr>
      <th scope="row">Variable</th>
      <td><code>x</code></td>
      <td><code>x</code></td>
      <td><code>x</code></td>
    </tr>
  </tbody>
</table>
<aside>

Due to the lambda calculus’s terseness, I will be making free use of several notational conveniences:

1. writing `λ x y . z` as an abbreviation of `λ x . λ y . z`.
2. writing `?` to stand for bits we don’t know yet, as though we had an environment supporting holes.
3. writing definitions as though we had a metalanguage.
4. referencing definitions elsewhere as though we had globals.
5. writing type signatures as though we had a type system, and even a typechecker, with as much polymorphism and inference as is convenient at any particular moment.
6. using syntactic recursion as though it existed.
7. using general recursion as though it made sense.
8. ignoring application order, normalization, reduction, substitution, values, references, allocation, copying, space, time, entropy, and any and all other such details whenever I feel like it.

By convention, I will name types in `TitleCase` and both term and (local) type variables in `camelCase`.

I will try to avoid pulling rabbits from hats too wantonly, but for now, I’ll ask you to suspend disbelief; I hope to revisit and justify some of these in later posts.

</aside>
<h2 id="unconditional-λ">Unconditional λ</h2>
<p>Lambdas are the only way to introduce values—they’re the only “literal” syntax in the language. We can therefore infer that the only kinds of runtime values must be closures. In an interpreter for the lambda calculus, closures might consist of the name of the introduced variable, the body of the lambda, &amp; a map relating the names and values of any variables it closed over when constructed (again, we assume strict lexical scoping). There are no bits, bytes, words, pointers, or objects in the language’s semantics; only this runtime representation of lambdas.</p>
<p>Likewise, lambdas are also the only way to introduce variables—there’s no standard library, built-ins, primitives, prelude, or global environment to provide common definitions. We’re truly baking the apple pie from scratch.</p>
<p>All of this raises the question: how do you <em>do</em> anything when you don’t even have <code>true</code> and <code>false</code>? Lambdas and variables don’t <em>do</em>, they merely <em>are</em>, so that leaves application. When all you have is application, everything looks like a lambda abstraction, so we’ll represent booleans using lambdas.</p>
<p>Of course, it’s not <em>just</em> booleans we’re after; <code>true</code> and <code>false</code> aren’t much use without <code>and</code>, <code>or</code>, <code>not</code>, <code>if</code>, and all the rest. To be useful, our representation of booleans should therefore suffice to define these, as well. But how do you define <code>if</code> without using <code>if</code>? In a lazy language like Haskell, we might define <code>if</code> as a function something like so:</p>
<div class="sourceCode" id="cb1"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb1-1"><a href="#cb1-1" aria-hidden="true"></a><span class="ot">if_ ::</span> <span class="dt">Bool</span> <span class="ot">-&gt;</span> a <span class="ot">-&gt;</span> a <span class="ot">-&gt;</span> a</span>
<span id="cb1-2"><a href="#cb1-2" aria-hidden="true"></a>if_ cond then_ else_ <span class="ot">=</span> <span class="kw">if</span> cond <span class="kw">then</span> then_ <span class="kw">else</span> else_</span></code></pre></div>
<p>In a strict language like JavaScript, we’d instead take functions for the alternatives:</p>
<div class="sourceCode" id="cb2"><pre class="sourceCode javascript"><code class="sourceCode javascript"><span id="cb2-1"><a href="#cb2-1" aria-hidden="true"></a><span class="kw">function</span> <span class="fu">if_</span>(cond<span class="op">,</span> then_<span class="op">,</span> else_) {</span>
<span id="cb2-2"><a href="#cb2-2" aria-hidden="true"></a>  <span class="cf">if</span> (cond) {</span>
<span id="cb2-3"><a href="#cb2-3" aria-hidden="true"></a>    <span class="fu">then_</span>()<span class="op">;</span></span>
<span id="cb2-4"><a href="#cb2-4" aria-hidden="true"></a>  } <span class="cf">else</span> {</span>
<span id="cb2-5"><a href="#cb2-5" aria-hidden="true"></a>    <span class="fu">else_</span>()<span class="op">;</span></span>
<span id="cb2-6"><a href="#cb2-6" aria-hidden="true"></a>  }</span>
<span id="cb2-7"><a href="#cb2-7" aria-hidden="true"></a>}</span></code></pre></div>
<p>Both these definitions use the language’s native booleans and <code>if</code> syntax (a tactic for implementing embedded DSLs known as “meta-circularity”), and thus aren’t viable in the lambda calculus. However, they do give us a hint: in both cases we have a function taking a condition, consequence, and alternative, and using the first to select one of the latter two. In the lambda calculus, we might start by writing:</p>
<pre><code>if = λ cond then else . ?</code></pre>
<p>(Note: there aren’t any keywords in the lambda calculus, so there’s nothing stopping me from naming variables things like <code>if</code>, a fact which I will take free advantage of.)</p>
<p>We’ve introduced a definition for <code>if</code>, as a function of three parameters; now what do we do with them? The lambda calculus’s stark palette makes it easy to enumerate <em>all</em> the things we can do with some variable <code>a</code>:</p>
<ol type="1">
<li><p>Ignore it, whether by simply not mentioning it at all (as in <code>λ a . λ b . b</code>), or by shadowing it with another lambda which binds the same name (as in <code>λ a . λ a . a</code>).</p></li>
<li><p>Mention it, whether on its own in the body of a lambda (as in <code>λ a . a</code> or <code>λ a . λ b . a</code>), somewhere within either side of an application (as in <code>λ a . λ b . a b</code> or <code>λ a . λ b . b a</code>), or some combination of both (as in <code>λ a . (λ b . a) a</code>).</p></li>
</ol>
<p>We could for example simply return <code>then</code> or <code>else</code>:</p>
<pre><code>if = λ cond then else . then
if = λ cond then else . else</code></pre>
<p>But in that case the conditional isn’t conditional at all—the value in no way depends on <code>cond</code>. Clearly the body must make use of all three variables if we want it to behave like the <code>if</code>s we know and love from other languages.</p>
<p>Taking a step back for a moment, let’s examine the roles of <code>if</code>’s arguments. <code>then</code> and <code>else</code> are passive; we only want to use or evaluate one or the other depending on the value of <code>cond</code>. <code>cond</code>, then, is the key: it takes the active role.</p>
<p>Thus, in the same way that our <code>if_</code> functions in Haskell &amp; JavaScript employed those language’s features to implement, we’re going to define <code>if cond then else</code> as the application of the condition to the other two parameters:</p>
<pre><code>if = λ cond then else . cond then else</code></pre>
<aside>

Under standard semantics for the lambda calculus, we could simplify this definition further by “[η-reducing][η-reduction]” it, noting that `λ x . f x` behaves the same as `f` alone. Nevertheless, we will leave this and likely other definitions in their full, η-long forms for the sake of clarity.

</aside>
<p>This feels strangely like cheating: surely we’ve only moved the problem around. Now instead of <code>if</code> making the decision about which argument to return, we’ve deferred it to <code>cond</code>. But <code>if</code> and <code>cond</code> aren’t the same, semantically; <code>if</code> takes a boolean and two other arguments and returns one of the latter, while <code>cond</code> <em>is</em> a boolean—albeit evidently a boolean represented as a function. Let’s make that precise by writing down <code>if</code>’s type:</p>
<pre><code>if : Bool -&gt; a -&gt; a -&gt; a</code></pre>
<p>Notwithstanding our use of the yet-to-be-defined name <code>Bool</code> for the type of the condition, this is the same type as we gave <code>if_</code> in Haskell; that’s a good sign that we’re on the right track! It takes a <code>Bool</code> and two arguments of type <code>a</code>, and it must return one of those because that’s the only way for it to come up with the <code>a</code> that it returns. But what <em>is</em> <code>Bool</code>?</p>
<p>Working backwards from the type and definition of <code>if</code>, we see that <code>cond</code> is applied to two arguments, and therefore must be a function of two parameters. Further, these are both of type <code>a</code>, and the value it returns must also be of type <code>a</code> for <code>if</code>’s type to hold. Thus, we can define the type <code>Bool</code> like so:</p>
<pre><code>Bool = ∀ a . a -&gt; a -&gt; a</code></pre>
<aside>

I’m making explicit use of the for-all quantifier here to drive home the point that any particular `Bool` value must be able to be applied to `then` and `else` values of any arbitrary type `a`, defined now or in the future.

By the same token, we could have written `if`’s type more explicitly as:

```
if : ∀ a . Bool -> a -> a -> a
```

Here and in future, local type variables can be assumed to be implicitly generalized in the same manner as Haskell if not otherwise quantified.

</aside>
<p>If a given <code>Bool</code> is a function of two arguments of arbitrary type, returning the same type, it must therefore select one of its arguments to return. There are only two distinguishable inhabitants of <code>Bool</code>, <code>true</code> and <code>false</code>, so we can therefore deduce that since <code>if</code> defers the selection of the result to the <code>Bool</code>, for <code>true</code> and <code>false</code> to actually differ they must make opposite selections. In other words, <code>true</code> must return the <code>then</code> parameter, while <code>false</code> must return the <code>else</code> one:</p>
<pre><code>true, false : Bool
true  = λ then else . then
false = λ then else . else</code></pre>
<p>We didn’t move the problem around after all; we solved it. What we noticed was a deeper insight: this encoding of booleans makes <code>if</code> redundant, since if we can apply <code>if</code> to a <code>Bool</code> and two arguments, we could equally apply the <code>Bool</code> to those arguments directly.</p>
<aside>

We chose to define `if` as applying the `Bool` to the other arguments in the same order it received them, but we could just as easily have swapped them:

```
if = λ cond then else . cond else then
```

In this case, `if` would be more useful since it would preserve our familiar argument ordering. As an exercise for the reader, consider what other effects this difference would have. What are the tradeoffs, syntactically and semantically? When would one or the other definition be more or less convenient?

</aside>
<p>It’s frequently convenient to conflate booleans with bits, their minimal representation, but in truth they’re not the same at all. Practically, some programming languages define booleans as a byte in memory, perhaps clamping its values to 0 and 1; others define them as instances of some boolean class, or constructors of an algebraic datatype. Some provide no formal relationship between <code>true</code> and <code>false</code> at all, save for a common interface—duck typing.</p>
<p>Mathematically, booleans are the values in propositional logic; the upper and lower bounds of a lattice; the zero and one of a semiring; the members of the set with cardinality 2; and many other things in many different contexts.</p>
<p>Operationally, booleans represent choice, and this is a pattern that we’ll see repeated: <em>encoding</em> a datatype with lambdas means <em>representing</em> the datatype as <em>functions supporting all of its operations</em>. All operations on booleans can be defined by selecting between two alternatives, which is precisely what our encoding does.</p>
<p>We can demonstrate this by defining some other operations on booleans, e.g. logical operators, using the encoding we’ve built thus far.</p>
<p><code>not</code> takes a single <code>Bool</code> and returns another:</p>
<pre><code>not : Bool -&gt; Bool
not = λ x . ?</code></pre>
<p>As when defining <code>if</code>, all we can do with a <code>Bool</code> is branch on it:</p>
<pre><code>not = λ x . if x ? ?</code></pre>
<aside>

As discussed in a previous aside, `if` is operationally redundant—i.e. `if x y z` is operationally equivalent to `x y z`—given the ordering of arguments to `Bool`s which we selected earlier. It is, however, pleasantly evocative, and so is used for clarity and so we can stop talking about that ordering decision.

</aside>
<p>But which arguments should we pass if we wish to return a <code>Bool</code> with the opposite value? Recall the definition of <code>Bool</code> from above:</p>
<pre><code>Bool = ∀ a . a -&gt; a -&gt; a</code></pre>
<p>To return a <code>Bool</code>, therefore, each argument must likewise be a <code>Bool</code>. The first argument will be selected if <code>x</code> is <code>true</code>, the second if <code>x</code> is <code>false</code>, so if we want the opposite value from <code>x</code> we can simply apply it to the opposite values in either position:</p>
<pre><code>not = λ x . if x false true</code></pre>
<p><code>not x</code> will therefore return <code>false</code> if <code>x</code> is <code>true</code>, and <code>true</code> if <code>x</code> is <code>false</code>; equationally:</p>
<pre><code>not true  = false
not false = true</code></pre>
<p>Which is precisely the meaning we intended <code>not</code> to have.</p>
<aside>

Note that this is not the only way that we could have implemented `not`.

`not`’s type is `Bool -> Bool`, which is equivalent to `(∀ a . a -> a -> a) -> ∀ a . a -> a -> a` Thus, we could also define `not` by taking the extra arguments that the _result_ `Bool` will be applied to, and using them directly, though in the opposite order:

```
not = λ x then else . if x else then
```

Or equivalently, but perhaps _slightly_ more familiar:

```
not = λ x . λ then else . if x else then
```

This style of definition can be surprising if you’re not used to so-called “curried functions” as commonly used in e.g. Haskell, but it’s operationally equivalent to the definition developed above. As an exercise, try to work out why that equivalence holds.

</aside>
<p><code>or</code> and <code>and</code> are closely related to one another, so we’ll define them simultaneously. Both take two <code>Bool</code>s and return a <code>Bool</code>:</p>
<pre><code>or, and : Bool -&gt; Bool -&gt; Bool
or  = λ x y . ?
and = λ x y . ?</code></pre>
<p>As with <code>not</code>, all we can do with <code>Bool</code>s is branch:</p>
<pre><code>or  = λ x y . if x ? ?
and = λ x y . if x ? ?</code></pre>
<p>For <code>or</code>, if <code>x</code> is <code>true</code>, we can return <code>true</code> immediately (“short-circuiting”). For <code>and</code>, it’s the opposite:</p>
<pre><code>or  = λ x y . if x true ?
and = λ x y . if x ?    false</code></pre>
<p>If <code>x</code> is <code>false</code>, <code>or</code> needs to test whether <code>y</code> is <code>true</code>; likewise, if <code>x</code> is <code>true</code>, <code>and</code> needs to test whether <code>y</code> is also <code>true</code>. Once more, all we can do with <code>Bool</code>s is branch:</p>
<pre><code>or  = λ x y . if x true       (if y ? ?)
and = λ x y . if x (if y ? ?) false</code></pre>
<p>And since we must return a <code>Bool</code>, we can use <code>true</code> and <code>false</code>:</p>
<pre><code>or  = λ x y . if x true              (if y true false)
and = λ x y . if x (if y true false) false</code></pre>
<p>Pleasantly, <code>if y true false</code> (and likewise <code>y true false</code>) is operationally equivalent to <code>y</code>. Using that equivalence, we can simplify these definitions, leaving us with:</p>
<pre><code>or  = λ x y . if x true y
and = λ x y . if x y    false</code></pre>
<aside>

As an exercise, define `xor : Bool -> Bool -> Bool`.

</aside>
<h2 id="conclusion">Conclusion</h2>
<p>In this post, we’ve explored defining a ubiquitous programming language feature—booleans—using nothing more than the spartan trappings of the lambda calculus. We’ve emerged with a language which can express not merely functions and their applications, but also fundamental metaphysical concepts such as truth.</p>
<p>In the next post, we’ll look at lambda-encodings of beauty: ML/Haskell-style algebraic datatypes.</p>]]></summary>
</entry>
<entry>
    <title>Pattern matching over recursive values in Swift</title>
    <link href="https://antitypical.com/posts/2015-07-01-pattern-matching-over-recursive-values-in-swift/index.html" />
    <id>https://antitypical.com/posts/2015-07-01-pattern-matching-over-recursive-values-in-swift/index.html</id>
    <published>2015-07-01T02:29:44Z</published>
    <updated>2015-07-01T02:29:44Z</updated>
    <summary type="html"><![CDATA[<p>Swift’s value types are <em>almost</em> able to represent algebraic data types. Unfortunately, they fall short of the mark when it comes to recursion, and while they’ve announced that their solution, indirect <code>case</code>s, will ship in a later build of Swift 2, there’s still reason to want them today.</p>
<!--more-->
<p>The standard solution is to use <code>Box&lt;T&gt;</code>, a function, or some other reference type to manually force an indirection for the recursive cases:</p>
<pre class="swift"><code>enum Expression {
	case Variable(String)
	case Abstraction(String, Box&lt;Expression&gt;)
	case Application(Box&lt;Expression&gt;, Box&lt;Expression&gt;)
}</code></pre>
<p>Unfortunately, this has a few significant warts:</p>
<ul>
<li>Clients of the API have to know about <code>Box&lt;T&gt;</code>; it can’t be a private implementation detail. This can in turn lead to ambiguities if APIs aren’t using a common dependency to provide the <code>Box&lt;T&gt;</code> type. Further, they have to box and unbox the values themselves.</li>
<li>Pattern matching cannot be performed recursively in a single step.</li>
</ul>
<p>Indirect cases will (I believe) resolve both of these issues, but there’s another solution we can apply today which solves both <em>and</em> provides a significant increase in the expressiveness of the type, at the expense of introducing a (useful) intermediary type.</p>
<p>To begin with, note that in Swift 2, it’s no longer necessary to box elements of parameterized types in enum cases. This suggests a straightforward refactoring: replace <code>Expression</code>’s recursive instances with elements of a type parameter:</p>
<pre class="swift"><code>enum Expression&lt;Recur&gt; {
	case Variable(String)
	case Abstraction(String, Recur)
	case Application(Recur, Recur)
}</code></pre>
<p>Now we’ve got an <code>Expression</code> type that can be instantiated with a given type parameter to recur. But if we try to describe the type of a recursive instance of it, we immediately run into a wall:</p>
<pre class="swift"><code>let expression: Expression&lt;Expression&lt;Expression&lt;…&gt;&gt;&gt;</code></pre>
<p>It would seem we’ve simply moved the problem from the <code>case</code>s to the type, and can now see more clearly why Swift doesn’t allow <code>case</code>s to recur directly: it amounts to an infinite type. Some indirection is required, <em>somewhere</em>, and by allowing the programmer to place it (whether by explicit boxing or an <code>indirect</code> keyword), the performance implications are somewhat under their control, rather than the compiler’s.</p>
<p>We need some way to tie <code>Expression</code> into a knot (as it were), looping back around into itself, but without requiring us to write out an infinite list of nested type parameters. If we were writing a function instead of a type, we could use the <a href="https://github.com/robrix/Prelude#fix"><code>fix</code></a> function, which computes the <a href="https://en.wikipedia.org/wiki/Fixed-point_combinator#Strict_fixed_point_combinator">least fixed point</a> of a function, to lift a nonrecursive function into a recursive one:</p>
<pre class="swift"><code>let factorial = fix { recur in
    { n in n &gt; 0 ? n * recur(n - 1) : 1 }
}</code></pre>
<p>Instead of making a recursive function, we make a nonrecursive function taking a function as a parameter, and return an inner function which calls through it in order to recur. <code>fix</code> calls the outer function with a closure which calls back into <code>fix</code>, tying the knot. Is there an analogous fixed point for types? If there were, we would expect it to have the same overall shape: it would apply a type constructor like <code>Expression&lt;T&gt;</code> to a type which itself provides the connection back to <code>Expression&lt;T&gt;</code>.</p>
<p>I’ll let you in on a secret: types are functions, too. <code>Expression&lt;T&gt;</code> is actually a function, abstracted over a parameter <code>T</code> to a concrete instance of <code>Expression</code> with <code>Recur</code> instantiated to <code>T</code>. And it turns out that, like other functions, types also have fixed points.</p>
<p>In Haskell (the inevitable destination of any discussion of fixed points in programming languages), we could write this <code>Fix</code> type of a parameter type <code>f</code> like so:</p>
<div class="sourceCode" id="cb5"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb5-1"><a href="#cb5-1" aria-hidden="true"></a><span class="kw">data</span> <span class="dt">Fix</span> f <span class="ot">=</span> <span class="dt">Fix</span> (f (<span class="dt">Fix</span> f))</span></code></pre></div>
<p>This is Haskell notation approaching its densest form, so let’s compare it with how <code>fix</code> (the least fixed point of functions) is defined in Swift:</p>
<pre class="swift"><code>public func fix&lt;A, B&gt;(f: (A -&gt; B) -&gt; A -&gt; B) -&gt; A -&gt; B {
	return { f(fix(f))($0) }
}</code></pre>
<p>The <code>fix</code> function applies <code>f</code>, the function parameter passed to <code>fix</code>, to the result of applying <code>fix</code> recursively to <code>f</code> again. It wraps this up in another closure to avoid infinite looping.</p>
<p>Analogously, the <code>Fix</code> type applies <code>f</code>, the type parameter passed to <code>fix</code>, to the result of applying <code>Fix</code> recursively to <code>f</code> again. Haskell is lazily-evaluated, so it doesn’t need to wrap the lot of it up again.</p>
<p>Let’s try writing <code>Fix</code> in Swift. It only has one <code>case</code>, so it can be a struct instead of an <code>enum</code>.</p>
<pre class="swift"><code>struct Fix {}</code></pre>
<p>Now it needs to have a type parameter, <code>F</code>.</p>
<pre class="swift"><code>struct Fix&lt;F&gt; {}</code></pre>
<p>So far so good. Now we need to apply <code>F</code> to itself, recursively. But doesn’t that cause the infinite sequence of nested types again? <code>Fix&lt;F&lt;Fix&lt;F&lt;…&gt;&gt;&gt;&gt;</code> is no improvement on <code>Expression&lt;Expression&lt;Expression&lt;…&gt;&gt;&gt;</code>.</p>
<p>Fortunately, Swift allows you to refer to a type without reference to its type parameters in its body:</p>
<pre class="swift"><code>struct Fix&lt;F&gt; {
	let body: F&lt;Fix&gt;
}</code></pre>
<p>Unfortunately, while <code>Fix</code> is a complete reference inside the body of this type, Swift doesn’t know that <code>F</code> can accept type parameters, and thus rejects this. We can be sneaky and use a <code>protocol</code> with a <code>typealias</code> to work around this:</p>
<pre class="swift"><code>protocol Fixable {
	typealias Recur
}

struct Fix&lt;F: Fixable&gt; {
	let body: F
}</code></pre>
<p>But now when we add the constraint to tie <code>F</code> into a knot, we run into a new issue: <code>swiftc</code> crashes. (<a href="http://www.openradar.appspot.com/20000145">rdar://20000145</a>).</p>
<pre class="swift"><code>protocol Fixable {
	typealias Recur
}

struct Fix&lt;F: Fixable where F.Recur == Fix&gt; {
	let body: F
}
// =&gt; fish: Job 1, &#39;swift boom.swift&#39; terminated by signal SIGSEGV (Address boundary error)</code></pre>
<p>Fortunately, while Swift can’t express a <em>generic</em> <code>Fix</code> over any arbitrary fixable type, it <em>can</em> express a fixed point of <code>Expression</code> <em>specifically</em>. Let’s call this new type <code>Term</code>. Once again, it’s a <code>struct</code>, and its body holds an <code>Expression</code> instantiated to itself. This one errors out, but it’s clear we’re getting closer:</p>
<pre class="swift"><code>struct Term {
	let body: Expression&lt;Term&gt;
}
// =&gt; error: recursive value type &#39;Term&#39; is not allowed</code></pre>
<p><code>Term</code> is recursive because it holds an <code>Expression</code> which in turn holds (in some of its cases) a <code>Recur</code>, which we’ve instantiated to <code>Term</code>. We need to reintroduce an indirection via a reference type like <code>Box&lt;T&gt;</code> or a function.</p>
<p>Haven’t we just moved the problem around again? Well, sort of. Certainly we still need to box the values, but now we can do it in one and only one place—<code>Term</code>—and additionally we can make it <code>private</code>, avoiding exposing our implementation details to our consumers. Our constructor and getter can handle the boxing and unboxing for us:</p>
<pre class="swift"><code>struct Term {
	init(body: Expression&lt;Term&gt;) {
		boxedBody = Box(body)
	}

	var body: Expression&lt;Term&gt; {
		return boxedBody.value
	}

	private let boxedBody: Box&lt;Expression&lt;Term&gt;&gt;
}</code></pre>
<p>That’s a pretty decent reason to use this approach right now (if you can’t wait for indirect cases). But it only solves one of the problems we mentioned initially; we still can’t pattern match recursively. For example, if we wanted to evaluate application expressions, we would want to write something like this:</p>
<pre class="swift"><code>switch expression {
case let .Application(.Abstraction(variable, body), argument):
	// substitute argument for variable in body
default:
	// throw an error
}</code></pre>
<p>But because of the <code>Term</code> and <code>Box</code>, neither of which can be matched through, we would have to write this instead:</p>
<pre class="swift"><code>switch expression {
case let .Application(abstraction, argument):
	switch abstraction.body {
	case let .Abstraction(variable, body):
		// substitute argument for variable in body
	default:
		break
	}
	fallthrough
default:
	// throw an error
}</code></pre>
<p>If we could flatten out the type, we could pattern match. Flattening out the type would put us straight back into the infinite sequence of <code>Expression&lt;…&gt;</code>s; but maybe we can only <em>partially</em> flatten it?</p>
<p>We don’t need to pattern match against arbitrarily-nested terms for this example; we just want to match against a single nested layer. Therefore, we really only need to flatten out a single step of the recursive type. We’d need to apply this for each appearance of <code>Recur</code> in <code>Expression</code>, replacing it with <code>Expression&lt;Recur&gt;</code>.</p>
<p>Replacing each instance of a type parameter with an instance of another type parameter sounds like a job for a <code>map</code> function. In Haskell, this function is known as <code>fmap</code>, for functor map, where functors are a kind of mathematical object with some specific shape, and where map preserves this shape. For example, the <code>Array.map</code> method, given some function <code>transform</code>, produces a new array with the same number of elements and in the same order (i.e. preserving the structure of the array), but with each element replaced by applying <code>transform</code>. Array, then, is a functor; and it turns out, so is our <code>Expression</code> tree.</p>
<p>In our case, <code>map</code> should replace the <code>Recur</code> instances with the result of applying some function to them. There are no instances of <code>Recur</code> in <code>Variable</code> cases, so it should just re-wrap the variable name in the resulting type; the <code>Abstraction</code> and <code>Application</code> cases will apply <code>transform</code>:</p>
<pre class="swift"><code>enum Expression&lt;Recur&gt; {
	…
	func map&lt;Other&gt;(transform: Recur -&gt; Other) -&gt; Expression&lt;Other&gt; {
		switch self {
		case let .Variable(x):
			return .Variable(x)
		case let .Abstraction(x, body):
			return .Abstraction(x, transform(body))
		case let .Application(a, b):
			return .Application(transform(a), transform(b))
		}
	}
}</code></pre>
<p>We can use this to implement <a href="http://patrickthomson.ghost.io/an-introduction-to-recursion-schemes/">recursion schemes</a>, improving our confidence in recursive functions over the type, but for now we’ll limit ourselves to enabling pattern matching. Given an <code>Expression&lt;Recur&gt;</code>, we want to replace each <code>Recur</code> with its recursive instantiation, <code>Expression&lt;Recur&gt;</code>. Otherwise put, we need a function of type <code>Expression&lt;Recur&gt; -&gt; Expression&lt;Expression&lt;Recur&gt;&gt;</code>. Let’s implement this as a method, and call it destructure (since it decomposes the structure of the type):</p>
<pre class="swift"><code>enum Expression&lt;Recur&gt; {
	…
	func destructure() -&gt; Expression&lt;Expression&lt;Recur&gt;&gt; {
		return map {
			// what do we do here?
		}
	}
}</code></pre>
<p>…but we can’t! To implement a function of type <code>Expression&lt;Recur&gt; -&gt; Expression&lt;Expression&lt;Recur&gt;&gt;</code> using <code>map</code>, we’d need a function of type <code>Recur -&gt; Expression&lt;Recur&gt;</code> to pass to it. There is no useful function that can do this; without knowing a <em>specific</em> (and actually recursive) type for <code>Recur</code>, we have no way to recover the <code>Expression&lt;Recur&gt;</code> that we want to return.</p>
<p>Instead, let’s use a constrained extension to limit ourselves to <code>Expression&lt;Term&gt;</code>. Unfortunately it’s not <em>quite</em> that simple, because Swift, for reasons beyond my knowledge (<a href="http://www.openradar.appspot.com/21512469">rdar://21512469</a>), forbids the obvious thing:</p>
<pre class="swift"><code>extension Expression where Recur == Term { … }
// =&gt; error: same-type requirement makes generic parameter &#39;Recur&#39; non-generic</code></pre>
<p>We’ll work around this using a protocol, <code>FixpointType</code>:</p>
<pre class="swift"><code>protocol FixpointType {
	typealias Fixed
}

extension Term: FixpointType {
	typealias Fixed = Expression&lt;Term&gt;
}</code></pre>
<p>Now we can constrain the extension to <code>FixpointType</code> like we want:</p>
<pre class="swift"><code>extension Expression where Recur : FixpointType, Recur.Fixed == Expression&lt;Recur&gt; {
	func destructure() -&gt; Expression&lt;Expression&lt;Recur&gt;&gt; {
		return map {
			// what do we do here?
		}
	}
}</code></pre>
<p>There are two problems remaining with this implementation:</p>
<ol type="1">
<li>We still don’t have a way to get an <code>Expression&lt;Recur&gt;</code> from a <code>Recur</code>.</li>
<li><code>swiftc</code> crashes. (<a href="http://openradar.appspot.com/21328632">rdar://21328632</a>)</li>
</ol>
<p>Fortunately, we can resolve the former by adding a property to the protocol:</p>
<pre class="swift"><code>protocol FixpointType {
	typealias Fixed
	var body: Fixed { get }
}</code></pre>
<p>With that out of the way, we can work around the crash by loosening the constraints slightly; we don’t actually require that <code>Recur.Fixed</code> be recursive; we just need to be able to name it. Now we can give the return type of <code>destructure</code> as <code>Expression&lt;Recur.Fixed&gt;</code>, and implement it in the obvious way, mapping each term to its body:</p>
<pre class="swift"><code>extension Expression where Recur : FixpointType {
	func destructure() -&gt; Expression&lt;Recur.Fixed&gt; {
		return map { term in term.body }
	}
}</code></pre>
<p>Now we can use <code>destructure</code> to implement evaluation of well-formed <code>.Application</code> expressions, using exactly the pattern matching we wanted in the first place:</p>
<pre class="swift"><code>switch expression.destructure() {
case let .Application(.Abstraction(variable, body), argument):
	// substitute argument for variable in body
default:
	// throw an error
}</code></pre>
<p><a href="https://gist.github.com/robrix/4696ec3c117aac97ef0b">Full code listing</a>.</p>]]></summary>
</entry>
<entry>
    <title>On the Order of Neptune</title>
    <link href="https://antitypical.com/posts/2014-04-20-on-the-order-of-neptune/index.html" />
    <id>https://antitypical.com/posts/2014-04-20-on-the-order-of-neptune/index.html</id>
    <published>2014-04-20T04:20:00Z</published>
    <updated>2014-04-20T04:20:00Z</updated>
    <summary type="html"><![CDATA[<p><a href="http://en.wikipedia.org/wiki/Inscribed_figure">Inscribe</a> the <a href="http://en.wikipedia.org/wiki/Neptune#Orbit_and_rotation">orbit of Neptune</a> in a square.</p>
<!--more-->
<p>Now, take a pair of integers as <em>x</em> and <em>y</em> coordinates across this square. Their size in bits determines the resolution at which they can measure this square.</p>
<p>An integer of <em>n</em> bits can hold any of 2<em>ⁿ</em> distinct values. 32-bit integers, therefore, would divide the square into a grid of 2³² points.</p>
<p>At 32 bits of resolution, adjacent coordinates, e.g. …<code>0101</code> and …<code>0110</code>, are about a kilometre apart on our square.</p>
<p>If we double the size of our integers, we now divide the square into a grid of 2⁶⁴ points.</p>
<p>At 64 bits of resolution, still covering the <em>entire span of the orbit of Neptune</em>, adjacent coordinates are about 0.24µm apart, or about 1% of the width of <a href="http://hypertextbook.com/facts/1999/BrianLey.shtml">an average human hair</a>.</p>
<p>And famously, populating a 128-bit address space would require us to <a href="https://blogs.oracle.com/bonwick/entry/128_bit_storage_are_you">boil the oceans</a>.</p>]]></summary>
</entry>

</feed>
