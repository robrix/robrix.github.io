<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
    <title>Antitypical</title>
    <link href="https://antitypical.com/feed.xml" rel="self" />
    <link href="https://antitypical.com" />
    <id>https://antitypical.com/feed.xml</id>
    <author>
        <name>Rob Rix</name>
        <email>rob.rix@me.com</email>
    </author>
    <updated>2021-06-07T19:49:02Z</updated>
    <entry>
    <title>Duality</title>
    <link href="https://antitypical.com/posts/2021-06-07-duality/index.html" />
    <id>https://antitypical.com/posts/2021-06-07-duality/index.html</id>
    <published>2021-06-07T19:49:02Z</published>
    <updated>2021-06-07T19:49:02Z</updated>
    <summary type="html"><![CDATA[<p>The rules for a variety of polarized classical connectives, in a focused sequent calculus presentation to reflect a variety of dualities.</p>
<!--more-->
<script src="https://polyfill.io/v3/polyfill.min.js?features=es6"></script>
<script type="text/javascript" id="MathJax-script" async src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-svg.js"></script>
<script type="text/x-mathjax-config">
MathJax.Hub.Config({
  tex2jax: { inlineMath: [["$","$"],["\\(","\\)"]] },
  "HTML-CSS": { linebreaks: { automatic: true } },
  "SVG":      { linebreaks: { automatic: true } }
});
</script>
<style type="text/css">
td.absent {
  text-align: center;
}
</style>
<p><span class="math display">$$
\require{bussproofs}
$$</span></p>
<table class="borderless">
<colgroup>
<col span="2">
<col span="2">
</colgroup>
<tbody>
<tr>
<th colspan="4">
<a name="additive">Additive</a>
</th>
</tr>
<tr>
<td class="absent">
no rule for ⊤ ⊢
</td>
<td>
<span class="math display">$$
        \begin{prooftree}
        \hskip 20pt
        \def\labelSpacing{8pt}
        \RightLabel{$\ ⊢ \kern1pt ⊤$}
        \AxiomC{}
        \UnaryInfC{$Γ ⊢ Δ, ⊤$}
        \end{prooftree}
        $$</span>
</td>
<td>
<span class="math display">$$
        \begin{prooftree}
        \hskip 20pt
        \def\labelSpacing{8pt}
        \LeftLabel{$0 \kern1pt ⊢$}
        \AxiomC{}
        \UnaryInfC{$0, Γ ⊢ Δ$}
        \end{prooftree}
        $$</span>
</td>
<td class="absent">
no rule for ⊢ 0
</td>
</tr>
<tr>
<td>
<span class="math display">$$
        \begin{prooftree}
        \def\labelSpacing{8pt}
        \LeftLabel{$\&amp; \kern1pt ⊢_1$}
        \Axiom$[A^-] \fCenter Γ ⊢ Δ$
        \UnaryInf$[A^- \&amp; B^-] \fCenter Γ ⊢ Δ$
        \end{prooftree}
        $$</span> <span class="math display">$$
        \begin{prooftree}
        \def\labelSpacing{8pt}
        \LeftLabel{$\&amp; \kern1pt ⊢_2$}
        \Axiom$[B^-] \fCenter Γ ⊢ Δ$
        \UnaryInf$[A^- \&amp; B^-] \fCenter Γ ⊢ Δ$
        \end{prooftree}
        $$</span>
</td>
<td>
<span class="math display">$$
        \begin{prooftree}
        \def\labelSpacing{8pt}
        \RightLabel{$\ ⊢ \kern1pt \&amp;$}
        \AxiomC{$Γ ⊢ Δ, A^-$}
        \AxiomC{$Γ ⊢ Δ, B^-$}
        \BinaryInfC{$Γ ⊢ Δ, A^- \&amp; B^-$}
        \end{prooftree}
        $$</span>
</td>
<td>
<span class="math display">$$
        \begin{prooftree}
        \def\labelSpacing{8pt}
        \LeftLabel{$⊕ \kern1pt ⊢$}
        \AxiomC{$A^+, Γ ⊢ Δ$}
        \AxiomC{$B^+, Γ ⊢ Δ$}
        \BinaryInfC{$A^+ ⊕ B^+, Γ ⊢ Δ$}
        \end{prooftree}
        $$</span>
</td>
<td>
<span class="math display">$$
        \begin{prooftree}
        \def\labelSpacing{8pt}
        \RightLabel{$\ ⊢ \kern1pt ⊕_1$}
        \Axiom$\fCenter Γ ⊢ Δ [A^+]$
        \UnaryInf$\fCenter Γ ⊢ Δ [A^+ ⊕ B^+]$
        \end{prooftree}
        $$</span> <span class="math display">$$
        \begin{prooftree}
        \def\labelSpacing{8pt}
        \RightLabel{$\ ⊢ \kern1pt ⊕_2$}
        \Axiom$\fCenter Γ ⊢ Δ [B^+]$
        \UnaryInf$\fCenter Γ ⊢ Δ [A^+ ⊕ B^+]$
        \end{prooftree}
        $$</span>
</td>
</tr>
<tr>
<td colspan="2" class="caption">
with — conjunctive
</td>
<td colspan="2" class="caption">
sum — disjunctive
</td>
</tr>
<tr>
<th colspan="4">
<a name="multiplicative">Multiplicative</a>
</th>
</tr>
<tr>
<td>
<span class="math display">$$
        \begin{prooftree}
        \hskip 20pt
        \def\labelSpacing{8pt}
        \LeftLabel{$⊥ \kern1pt ⊢$}
        \AxiomC{}
        \UnaryInfC{$[⊥] Γ ⊢ Δ$}
        \end{prooftree}
        $$</span>
</td>
<td>
<span class="math display">$$
        \begin{prooftree}
        \hskip 20pt
        \def\labelSpacing{8pt}
        \RightLabel{$\ ⊢ \kern1pt ⊥$}
        \Axiom$\fCenter Γ ⊢ Δ$
        \UnaryInf$\fCenter Γ ⊢ Δ, ⊥$
        \end{prooftree}
        $$</span>
</td>
<td>
<span class="math display">$$
        \begin{prooftree}
        \hskip 20pt
        \def\labelSpacing{8pt}
        \LeftLabel{$1 \kern1pt ⊢$}
        \Axiom$\fCenter Γ ⊢ Δ$
        \UnaryInf$1, \fCenter Γ ⊢ Δ$
        \end{prooftree}
        $$</span>
</td>
<td>
<span class="math display">$$
        \begin{prooftree}
        \hskip 20pt
        \def\labelSpacing{8pt}
        \RightLabel{$\ ⊢ \kern1pt 1$}
        \AxiomC{}
        \UnaryInfC{$Γ ⊢ Δ [1]$}
        \end{prooftree}
        $$</span>
</td>
</tr>
<tr>
<td colspan="2">
<span class="math display">$$
        \begin{prooftree}
        \hskip -10pt
        \def\labelSpacing{8pt}
        \LeftLabel{$⅋\ \ \kern1pt ⊢$}
        \AxiomC{$[A^-] Γ ⊢ Δ$}
        \AxiomC{$[B^-] Γ ⊢ Δ$}
        \BinaryInfC{$[A^-\ ⅋\ \ \ B^-] Γ ⊢ Δ$}
        \end{prooftree}
        \begin{prooftree}
        \hskip 10pt
        \def\labelSpacing{8pt}
        \RightLabel{$\ ⊢ \kern1pt ⅋$}
        \Axiom$\fCenter Γ ⊢ Δ, A^-, B^-$
        \UnaryInf$\fCenter Γ ⊢ Δ, A^-\ ⅋\ \ \ B^-$
        \end{prooftree}
        $$</span>
</td>
<td colspan="2">
<span class="math display">$$
        \begin{prooftree}
        \hskip -10pt
        \def\labelSpacing{8pt}
        \LeftLabel{$⊗ \kern1pt ⊢$}
        \Axiom$A^+, B^+, \fCenter Γ ⊢ Δ$
        \UnaryInf$A^+ ⊗ B^+, \fCenter Γ ⊢ Δ$
        \end{prooftree}
        \begin{prooftree}
        \hskip 10pt
        \def\labelSpacing{8pt}
        \RightLabel{$\ ⊢ \kern1pt ⊗$}
        \AxiomC{$Γ ⊢ Δ [A^+]$}
        \AxiomC{$Γ ⊢ Δ [B^+]$}
        \BinaryInfC{$Γ ⊢ Δ [A^+ ⊗ B^+]$}
        \end{prooftree}
        $$</span>
</td>
</tr>
<tr>
<td colspan="2" class="caption">
par — disjunctive
</td>
<td colspan="2" class="caption">
tensor — conjunctive
</td>
</tr>
<tr>
<th colspan="4">
<a name="implicative">Implicative</a>
</th>
</tr>
<tr>
<td colspan="2">
<span class="math display">$$
        \begin{prooftree}
        \hskip -10pt
        \def\labelSpacing{8pt}
        \LeftLabel{$→ \kern1pt ⊢$}
        \AxiomC{$\fCenter Γ ⊢ Δ [A^+]$}
        \AxiomC{$[B^-] \fCenter Γ ⊢ Δ$}
        \BinaryInfC{$[A^+ → B^-] \fCenter Γ ⊢ Δ$}
        \end{prooftree}
        \begin{prooftree}
        \hskip 10pt
        \def\labelSpacing{8pt}
        \RightLabel{$\ ⊢ \kern1pt →$}
        \Axiom$A^+, \fCenter Γ ⊢ Δ, B^-$
        \UnaryInf$\fCenter Γ ⊢ Δ, A^+ → B^-$
        \end{prooftree}
        $$</span>
</td>
<td colspan="2">
<span class="math display">$$
        \begin{prooftree}
        \hskip -10pt
        \def\labelSpacing{8pt}
        \LeftLabel{$- \kern1pt ⊢$}
        \Axiom$A^+, \fCenter Γ ⊢ Δ, B^-$
        \UnaryInf$A^+ - B^-, \fCenter Γ ⊢ Δ$
        \end{prooftree}
        \begin{prooftree}
        \hskip 10pt
        \def\labelSpacing{8pt}
        \RightLabel{$\ ⊢ \kern1pt -$}
        \AxiomC{$\fCenter Γ ⊢ Δ [A^+]$}
        \AxiomC{$[B^-] \fCenter Γ ⊢ Δ$}
        \BinaryInfC{$\fCenter Γ ⊢ Δ [A^+ - B^-]$}
        \end{prooftree}
        $$</span>
</td>
</tr>
<tr>
<td colspan="2" class="caption">
implication
</td>
<td colspan="2" class="caption">
subtraction
</td>
</tr>
<tr>
<th colspan="4">
<a name="negating">Negating</a>
</th>
</tr>
<tr>
<td colspan="2">
<span class="math display">$$
        \begin{prooftree}
        \hskip -10pt
        \def\labelSpacing{8pt}
        \LeftLabel{$¬ \kern1pt ⊢$}
        \Axiom$\fCenter Γ ⊢ Δ [A^+]$
        \UnaryInf$[¬A^+] \fCenter Γ ⊢ Δ$
        \end{prooftree}
        \begin{prooftree}
        \hskip 10pt
        \def\labelSpacing{8pt}
        \RightLabel{$\ ⊢ \kern1pt ¬$}
        \Axiom$A^+, \fCenter Γ ⊢ Δ$
        \UnaryInf$\fCenter Γ ⊢ Δ, ¬A^+$
        \end{prooftree}
        $$</span>
</td>
<td colspan="2">
<span class="math display">$$
        \begin{prooftree}
        \hskip -10pt
        \def\labelSpacing{8pt}
        \LeftLabel{$\sim \kern1pt ⊢$}
        \Axiom$\fCenter Γ ⊢ Δ, A^-$
        \UnaryInf$\sim\kern -3pt A^-, \fCenter Γ ⊢ Δ$
        \end{prooftree}
        \begin{prooftree}
        \hskip 10pt
        \def\labelSpacing{8pt}
        \RightLabel{$\ ⊢ \kern1pt \sim$}
        \Axiom$[A^-] \fCenter Γ ⊢ Δ$
        \UnaryInf$\fCenter Γ ⊢ Δ [\sim\kern -3pt A^-]$
        \end{prooftree}
        $$</span>
</td>
</tr>
<tr>
<td colspan="2" class="caption">
positive-to-negative negation
</td>
<td colspan="2" class="caption">
negative-to-positive negation
</td>
</tr>
<tr>
<th colspan="4">
<a name="shifts">Shifts</a>
</th>
</tr>
<tr>
<td colspan="2">
<span class="math display">$$
        \begin{prooftree}
        \hskip -10pt
        \def\labelSpacing{8pt}
        \LeftLabel{$↑ \kern1pt ⊢$}
        \Axiom$A^+, \fCenter Γ ⊢ Δ$
        \UnaryInf$[↑A^+] \fCenter Γ ⊢ Δ$
        \end{prooftree}
        \begin{prooftree}
        \hskip 10pt
        \def\labelSpacing{8pt}
        \RightLabel{$\ ⊢ \kern1pt ↑$}
        \Axiom$\fCenter Γ ⊢ Δ, A^+$
        \UnaryInf$\fCenter Γ ⊢ Δ, ↑A^+$
        \end{prooftree}
        $$</span>
</td>
<td colspan="2">
<span class="math display">$$
        \begin{prooftree}
        \hskip -10pt
        \def\labelSpacing{8pt}
        \LeftLabel{$↓ \kern1pt ⊢$}
        \Axiom$A^-, \fCenter Γ ⊢ Δ$
        \UnaryInf$↓A^-, \fCenter Γ ⊢ Δ$
        \end{prooftree}
        \begin{prooftree}
        \hskip 10pt
        \def\labelSpacing{8pt}
        \RightLabel{$\ ⊢ \kern1pt ↓$}
        \Axiom$\fCenter Γ ⊢ Δ, A^-$
        \UnaryInf$\fCenter Γ ⊢ Δ [↓A^-]$
        \end{prooftree}
        $$</span>
</td>
</tr>
<tr>
<td colspan="2" class="caption">
positive-to-negative shift
</td>
<td colspan="2" class="caption">
negative-to-positive shift
</td>
</tr>
<tr>
<th colspan="4">
<a name="core">Core</a>
</th>
</tr>
<tr>
<td colspan="4">
<span class="math display">$$
        \begin{prooftree}
        \hskip -10pt
        \RightLabel{$\ init$}
        \AxiomC{}
        \UnaryInfC{$A ⊢ A$}
        \end{prooftree}
        \begin{prooftree}
        \hskip 10pt
        \RightLabel{$\ cut$}
        \AxiomC{$Γ ⊢ Δ, A$}
        \AxiomC{$A, Γ ⊢ Δ$}
        \BinaryInfC{$Γ ⊢ Δ$}
        \end{prooftree}
        $$</span>
</td>
</tr>
<tr>
<th colspan="4">
<a name="structural">Structural</a>
</th>
</tr>
<tr>
<td colspan="2">
<span class="math display">$$
        \begin{prooftree}
        \hskip -10pt
        \def\labelSpacing{8pt}
        \LeftLabel{$weaken ⊢$}
        \Axiom$\fCenter Γ ⊢ Δ$
        \UnaryInf$A, \fCenter Γ ⊢ Δ$
        \end{prooftree}
        \begin{prooftree}
        \hskip 10pt
        \def\labelSpacing{8pt}
        \RightLabel{$\ ⊢ weaken$}
        \Axiom$\fCenter Γ ⊢ Δ$
        \UnaryInf$\fCenter Γ ⊢ Δ, A$
        \end{prooftree}
        $$</span>
</td>
<td colspan="2">
<span class="math display">$$
        \begin{prooftree}
        \hskip -10pt
        \def\labelSpacing{8pt}
        \LeftLabel{$contract ⊢$}
        \Axiom$A, A, \fCenter Γ ⊢ Δ$
        \UnaryInf$A, \fCenter Γ ⊢ Δ$
        \end{prooftree}
        \begin{prooftree}
        \hskip 10pt
        \def\labelSpacing{8pt}
        \RightLabel{$\ ⊢ contract$}
        \Axiom$\fCenter Γ ⊢ Δ, A, A$
        \UnaryInf$\fCenter Γ ⊢ Δ, A$
        \end{prooftree}
        $$</span>
</td>
</tr>
<tr>
<td colspan="4" class="caption">
note that the customary exchange rule is not required as this presentation’s contexts are unordered
</td>
</tr>
<tr>
<th colspan="4">
<a name="algebraic-laws">Algebraic Laws</a>
</th>
</tr>
<tr>
<td>
\[ \sim \kern -3pt (A^- \&amp; B^-) ≈\kern 3pt \sim \kern -3pt A^- ⊕ \sim \kern -3pt B^- \]
</td>
<td>
\[ \sim \kern -3pt (A^- ⅋\ \ \ B^-) ≈\kern 3pt \sim \kern -3pt A^- ⊗ \sim \kern -3pt B^- \]
</td>
<td>
\[ ¬(A^+ ⊕ B^+) ≈ ¬A^+ \&amp; ¬B^+ \]
</td>
<td>
\[ ¬(A^+ ⊗ B^+) ≈ ¬A^+ ⅋\ \ \ ¬B^+ \]
</td>
</tr>
<tr>
<td>
<span class="math display">$$
        \sim \kern -1pt ⊥ ≈ 1
        $$</span>
</td>
<td>
<span class="math display">$$
        \sim \kern -1pt ⊤ ≈ 0
        $$</span>
</td>
<td>
\[ ¬0 ≈ ⊤ \]
</td>
<td>
\[ ¬1 ≈ ⊥ \]
</td>
</tr>
<tr>
<td>
\[ \sim \kern -3pt ¬A^+ ≈ A^+ \]
</td>
<td>
\[ \sim \kern -3pt (A^+ → B^-) ≈ A^+ - B^- \]
</td>
<td>
\[ ¬(A^+ - B^-) ≈ A^+ → B^- \]
</td>
<td>
\[ ¬\sim \kern -3pt A^- ≈ A^- \]
</td>
</tr>
<tr>
<td class="caption" colspan="4">
de Morgan dualities
</td>
</tr>
</tbody>
</table>]]></summary>
</entry>
<entry>
    <title>All you need is λ, part one: booleans</title>
    <link href="https://antitypical.com/posts/2020-03-29-all-you-need-is-lambda-1-booleans/index.html" />
    <id>https://antitypical.com/posts/2020-03-29-all-you-need-is-lambda-1-booleans/index.html</id>
    <published>2020-03-29T20:17:26Z</published>
    <updated>2020-03-29T20:17:26Z</updated>
    <summary type="html"><![CDATA[<p>Nearly a century ago, Alonzo Church invented the simple, elegant, and yet elusive lambda calculus. Along with Alan Turing, he then proved the Church-Turing thesis: that anything computable with a Turing machine can also be computed in the lambda calculus. However, nearly as soon as we had digital computers, we started inventing programming languages, and with them a vast treasure of features, beautiful and terrible, many of which seem very hard to relate to the fundamental nature of computability, let alone the lambda calculus specifically.</p>
<!--more-->
<p>While it’s true that anything which can be computed, period, can be computed in the lambda calculus, you might not want to: it’s austere, to say the least, and was not designed with modern sensibilities regarding readability in mind. We developed all those languages and features for a reason! Still, Church demonstrated not just that it was possible to compute anything computable with the lambda calculus, but also <em>how</em> one might do so.</p>
<p>In this series, we’ll examine some ways to express common programming language features using the minimalistic tools of the lambda calculus. We begin with perhaps the most ubiquitous type: booleans.</p>
<h2 id="λ-is-blind">λ is blind</h2>
<p>The lambda calculus’s austerity is extreme: you don’t even have booleans. All you have are:</p>
<ol type="1">
<li><p>Lambda abstractions;</p></li>
<li><p>Applications; and</p></li>
<li><p>Variables.</p></li>
</ol>
<p>We’ll now review these in some detail; feel free to skip this section if you’re already familiar with the lambda calculus.</p>
<h3 id="lambda-abstractions">Lambda abstractions</h3>
<p>Lambda abstractions (“lambdas,” “abstractions,” and “functions” will also be used interchangeably) introduce a function of a single variable.</p>
<p>Abstractions are written <code>λ x . y</code>, for variable <code>x</code> and expression <code>y</code>, where <code>x</code> is now available as a bound variable in the body, and any enclosing definition of <code>x</code> is shadowed (i.e. <code>λ x . λ x . x</code> = <code>λ x . λ y . y</code> ≠ <code>λ x . λ y . x</code>). (We shall assume strictly lexical scoping for the time being.)</p>
<p>In Haskell, we would write <code>\ x -&gt; y</code> instead; in JavaScript, <code>function (x) { return y }</code> or <code>(x) =&gt; y</code>.</p>
<h3 id="applications">Applications</h3>
<p>Applications (“function application” and “function call” will be used interchangeably) apply the result of the expression on the left to the expression on the right.</p>
<p>Applications are written as <code>x y</code>, for expressions x and y, and left-associated, i.e. <code>a b c</code> = <code>(a b) c</code> ≠ <code>a (b c)</code>. Function application binds tighter than lambda abstraction, i.e. <code>λ x . λ y . y x</code> = <code>λ x . λ y . (y x)</code> ≠ <code>λ x . (λ y . y) x</code>.</p>
<p>The syntax is the same in Haskell; in JavaScript, we would write <code>x(y)</code> or <code>a(b, c)</code>. Note however that since lambda calculus functions are all single-argument functions, a more direct (though less idiomatic) equivalent for the latter would be <code>a(b)(c)</code>.</p>
<h3 id="variables">Variables</h3>
<p>Variables introduced by enclosing lambdas.</p>
<p>Variable are written as more or less arbitrary names, typically alphanumeric (e.g. <code>x</code> or <code>y0</code> or <code>thing</code>); however, we will feel free to include non-alphanumeric characters in names as we see fit, since the paucity of syntax means there’s little risk of ambiguity.</p>
<p>Since the only available variables are those bound by enclosing lambdas, we can also infer that there are no <code>let</code> bindings for local variables, and no globals of any sort; the lambda calculus doesn’t come with a standard library.</p>
<h3 id="summary">Summary</h3>
<p>In quasi-BNF, the grammar for the lambda calculus is extremely minimal:</p>
<figure class="center">
<p><em>e</em> <strong>:=</strong> <code>λ</code> <em>x</em> <code>.</code> <em>e</em> <strong>|</strong> <em>e</em> <em>e</em> <strong>|</strong> <em>x</em> <strong>|</strong> (<em>e</em>)</p>
</figure>
<p>And finally, this table gives a side-by-side comparison of the syntax of the lambda calculus with the corresponding syntax in Haskell &amp; JavaScript:</p>
<table>
<caption>
Syntax of the lambda calculus, Haskell, &amp; JavaScript
</caption>
<thead>
<tr>
<th scope="col">
</th>
<th scope="col">
Lambda calculus
</th>
<th scope="col">
Haskell
</th>
<th scope="col">
JavaScript
</th>
</tr>
</thead>
<tbody>
<tr>
<th scope="row">
Abstraction
</th>
<td>
<code>λ x . y</code>
</td>
<td>
<code>\ x -&gt; y</code>
</td>
<td>
<code>(x) =&gt; y</code>
</td>
</tr>
<tr>
<th scope="row">
Application
</th>
<td>
<code>f x</code>
</td>
<td>
<code>f x</code>
</td>
<td>
<code>f(x)</code>
</td>
</tr>
<tr>
<th scope="row">
Variable
</th>
<td>
<code>x</code>
</td>
<td>
<code>x</code>
</td>
<td>
<code>x</code>
</td>
</tr>
</tbody>
</table>
<aside>
<p>Due to the lambda calculus’s terseness, I will be making free use of several notational conveniences:</p>
<ol type="1">
<li>writing <code>λ x y . z</code> as an abbreviation of <code>λ x . λ y . z</code>.</li>
<li>writing <code>?</code> to stand for bits we don’t know yet, as though we had an environment supporting holes.</li>
<li>writing definitions as though we had a metalanguage.</li>
<li>referencing definitions elsewhere as though we had globals.</li>
<li>writing type signatures as though we had a type system, and even a typechecker, with as much polymorphism and inference as is convenient at any particular moment.</li>
<li>using syntactic recursion as though it existed.</li>
<li>using general recursion as though it made sense.</li>
<li>ignoring application order, normalization, reduction, substitution, values, references, allocation, copying, space, time, entropy, and any and all other such details whenever I feel like it.</li>
</ol>
<p>By convention, I will name types in <code>TitleCase</code> and both term and (local) type variables in <code>camelCase</code>.</p>
<p>I will try to avoid pulling rabbits from hats too wantonly, but for now, I’ll ask you to suspend disbelief; I hope to revisit and justify some of these in later posts.</p>
</aside>
<h2 id="unconditional-λ">Unconditional λ</h2>
<p>Lambdas are the only way to introduce values—they’re the only “literal” syntax in the language. We can therefore infer that the only kinds of runtime values must be closures. In an interpreter for the lambda calculus, closures might consist of the name of the introduced variable, the body of the lambda, &amp; a map relating the names and values of any variables it closed over when constructed (again, we assume strict lexical scoping). There are no bits, bytes, words, pointers, or objects in the language’s semantics; only this runtime representation of lambdas.</p>
<p>Likewise, lambdas are also the only way to introduce variables—there’s no standard library, built-ins, primitives, prelude, or global environment to provide common definitions. We’re truly baking the apple pie from scratch.</p>
<p>All of this raises the question: how do you <em>do</em> anything when you don’t even have <code>true</code> and <code>false</code>? Lambdas and variables don’t <em>do</em>, they merely <em>are</em>, so that leaves application. When all you have is application, everything looks like a lambda abstraction, so we’ll represent booleans using lambdas.</p>
<p>Of course, it’s not <em>just</em> booleans we’re after; <code>true</code> and <code>false</code> aren’t much use without <code>and</code>, <code>or</code>, <code>not</code>, <code>if</code>, and all the rest. To be useful, our representation of booleans should therefore suffice to define these, as well. But how do you define <code>if</code> without using <code>if</code>? In a lazy language like Haskell, we might define <code>if</code> as a function something like so:</p>
<div class="sourceCode" id="cb1"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb1-1"><a href="#cb1-1" aria-hidden="true"></a><span class="ot">if_ ::</span> <span class="dt">Bool</span> <span class="ot">-&gt;</span> a <span class="ot">-&gt;</span> a <span class="ot">-&gt;</span> a</span>
<span id="cb1-2"><a href="#cb1-2" aria-hidden="true"></a>if_ cond then_ else_ <span class="ot">=</span> <span class="kw">if</span> cond <span class="kw">then</span> then_ <span class="kw">else</span> else_</span></code></pre></div>
<p>In a strict language like JavaScript, we’d instead take functions for the alternatives:</p>
<div class="sourceCode" id="cb2"><pre class="sourceCode javascript"><code class="sourceCode javascript"><span id="cb2-1"><a href="#cb2-1" aria-hidden="true"></a><span class="kw">function</span> <span class="fu">if_</span>(cond<span class="op">,</span> then_<span class="op">,</span> else_) {</span>
<span id="cb2-2"><a href="#cb2-2" aria-hidden="true"></a>  <span class="cf">if</span> (cond) {</span>
<span id="cb2-3"><a href="#cb2-3" aria-hidden="true"></a>    <span class="fu">then_</span>()<span class="op">;</span></span>
<span id="cb2-4"><a href="#cb2-4" aria-hidden="true"></a>  } <span class="cf">else</span> {</span>
<span id="cb2-5"><a href="#cb2-5" aria-hidden="true"></a>    <span class="fu">else_</span>()<span class="op">;</span></span>
<span id="cb2-6"><a href="#cb2-6" aria-hidden="true"></a>  }</span>
<span id="cb2-7"><a href="#cb2-7" aria-hidden="true"></a>}</span></code></pre></div>
<p>Both these definitions use the language’s native booleans and <code>if</code> syntax (a tactic for implementing embedded DSLs known as “meta-circularity”), and thus aren’t viable in the lambda calculus. However, they do give us a hint: in both cases we have a function taking a condition, consequence, and alternative, and using the first to select one of the latter two. In the lambda calculus, we might start by writing:</p>
<pre><code>if = λ cond then else . ?</code></pre>
<p>(Note: there aren’t any keywords in the lambda calculus, so there’s nothing stopping me from naming variables things like <code>if</code>, a fact which I will take free advantage of.)</p>
<p>We’ve introduced a definition for <code>if</code>, as a function of three parameters; now what do we do with them? The lambda calculus’s stark palette makes it easy to enumerate <em>all</em> the things we can do with some variable <code>a</code>:</p>
<ol type="1">
<li><p>Ignore it, whether by simply not mentioning it at all (as in <code>λ a . λ b . b</code>), or by shadowing it with another lambda which binds the same name (as in <code>λ a . λ a . a</code>).</p></li>
<li><p>Mention it, whether on its own in the body of a lambda (as in <code>λ a . a</code> or <code>λ a . λ b . a</code>), somewhere within either side of an application (as in <code>λ a . λ b . a b</code> or <code>λ a . λ b . b a</code>), or some combination of both (as in <code>λ a . (λ b . a) a</code>).</p></li>
</ol>
<p>We could for example simply return <code>then</code> or <code>else</code>:</p>
<pre><code>if = λ cond then else . then
if = λ cond then else . else</code></pre>
<p>But in that case the conditional isn’t conditional at all—the value in no way depends on <code>cond</code>. Clearly the body must make use of all three variables if we want it to behave like the <code>if</code>s we know and love from other languages.</p>
<p>Taking a step back for a moment, let’s examine the roles of <code>if</code>’s arguments. <code>then</code> and <code>else</code> are passive; we only want to use or evaluate one or the other depending on the value of <code>cond</code>. <code>cond</code>, then, is the key: it takes the active role.</p>
<p>Thus, in the same way that our <code>if_</code> functions in Haskell &amp; JavaScript employed those language’s features to implement, we’re going to define <code>if cond then else</code> as the application of the condition to the other two parameters:</p>
<pre><code>if = λ cond then else . cond then else</code></pre>
<aside>
<p>Under standard semantics for the lambda calculus, we could simplify this definition further by “<a href="https://en.wikipedia.org/wiki/Lambda_calculus#η-reduction">η-reducing</a>” it, noting that <code>λ x . f x</code> behaves the same as <code>f</code> alone. Nevertheless, we will leave this and likely other definitions in their full, η-long forms for the sake of clarity.</p>
</aside>
<p>This feels strangely like cheating: surely we’ve only moved the problem around. Now instead of <code>if</code> making the decision about which argument to return, we’ve deferred it to <code>cond</code>. But <code>if</code> and <code>cond</code> aren’t the same, semantically; <code>if</code> takes a boolean and two other arguments and returns one of the latter, while <code>cond</code> <em>is</em> a boolean—albeit evidently a boolean represented as a function. Let’s make that precise by writing down <code>if</code>’s type:</p>
<pre><code>if : Bool -&gt; a -&gt; a -&gt; a</code></pre>
<p>Notwithstanding our use of the yet-to-be-defined name <code>Bool</code> for the type of the condition, this is the same type as we gave <code>if_</code> in Haskell; that’s a good sign that we’re on the right track! It takes a <code>Bool</code> and two arguments of type <code>a</code>, and it must return one of those because that’s the only way for it to come up with the <code>a</code> that it returns. But what <em>is</em> <code>Bool</code>?</p>
<p>Working backwards from the type and definition of <code>if</code>, we see that <code>cond</code> is applied to two arguments, and therefore must be a function of two parameters. Further, these are both of type <code>a</code>, and the value it returns must also be of type <code>a</code> for <code>if</code>’s type to hold. Thus, we can define the type <code>Bool</code> like so:</p>
<pre><code>Bool = ∀ a . a -&gt; a -&gt; a</code></pre>
<aside>
<p>I’m making explicit use of the for-all quantifier here to drive home the point that any particular <code>Bool</code> value must be able to be applied to <code>then</code> and <code>else</code> values of any arbitrary type <code>a</code>, defined now or in the future.</p>
<p>By the same token, we could have written <code>if</code>’s type more explicitly as:</p>
<pre><code>if : ∀ a . Bool -&gt; a -&gt; a -&gt; a</code></pre>
<p>Here and in future, local type variables can be assumed to be implicitly generalized in the same manner as Haskell if not otherwise quantified.</p>
</aside>
<p>If a given <code>Bool</code> is a function of two arguments of arbitrary type, returning the same type, it must therefore select one of its arguments to return. There are only two distinguishable inhabitants of <code>Bool</code>, <code>true</code> and <code>false</code>, so we can therefore deduce that since <code>if</code> defers the selection of the result to the <code>Bool</code>, for <code>true</code> and <code>false</code> to actually differ they must make opposite selections. In other words, <code>true</code> must return the <code>then</code> parameter, while <code>false</code> must return the <code>else</code> one:</p>
<pre><code>true, false : Bool
true  = λ then else . then
false = λ then else . else</code></pre>
<p>We didn’t move the problem around after all; we solved it. What we noticed was a deeper insight: this encoding of booleans makes <code>if</code> redundant, since if we can apply <code>if</code> to a <code>Bool</code> and two arguments, we could equally apply the <code>Bool</code> to those arguments directly.</p>
<aside>
<p>We chose to define <code>if</code> as applying the <code>Bool</code> to the other arguments in the same order it received them, but we could just as easily have swapped them:</p>
<pre><code>if = λ cond then else . cond else then</code></pre>
<p>In this case, <code>if</code> would be more useful since it would preserve our familiar argument ordering. As an exercise for the reader, consider what other effects this difference would have. What are the tradeoffs, syntactically and semantically? When would one or the other definition be more or less convenient?</p>
</aside>
<p>It’s frequently convenient to conflate booleans with bits, their minimal representation, but in truth they’re not the same at all. Practically, some programming languages define booleans as a byte in memory, perhaps clamping its values to 0 and 1; others define them as instances of some boolean class, or constructors of an algebraic datatype. Some provide no formal relationship between <code>true</code> and <code>false</code> at all, save for a common interface—duck typing.</p>
<p>Mathematically, booleans are the values in propositional logic; the upper and lower bounds of a lattice; the zero and one of a semiring; the members of the set with cardinality 2; and many other things in many different contexts.</p>
<p>Operationally, booleans represent choice, and this is a pattern that we’ll see repeated: <em>encoding</em> a datatype with lambdas means <em>representing</em> the datatype as <em>functions supporting all of its operations</em>. All operations on booleans can be defined by selecting between two alternatives, which is precisely what our encoding does.</p>
<p>We can demonstrate this by defining some other operations on booleans, e.g. logical operators, using the encoding we’ve built thus far.</p>
<p><code>not</code> takes a single <code>Bool</code> and returns another:</p>
<pre><code>not : Bool -&gt; Bool
not = λ x . ?</code></pre>
<p>As when defining <code>if</code>, all we can do with a <code>Bool</code> is branch on it:</p>
<pre><code>not = λ x . if x ? ?</code></pre>
<aside>
<p>As discussed in a previous aside, <code>if</code> is operationally redundant—i.e. <code>if x y z</code> is operationally equivalent to <code>x y z</code>—given the ordering of arguments to <code>Bool</code>s which we selected earlier. It is, however, pleasantly evocative, and so is used for clarity and so we can stop talking about that ordering decision.</p>
</aside>
<p>But which arguments should we pass if we wish to return a <code>Bool</code> with the opposite value? Recall the definition of <code>Bool</code> from above:</p>
<pre><code>Bool = ∀ a . a -&gt; a -&gt; a</code></pre>
<p>To return a <code>Bool</code>, therefore, each argument must likewise be a <code>Bool</code>. The first argument will be selected if <code>x</code> is <code>true</code>, the second if <code>x</code> is <code>false</code>, so if we want the opposite value from <code>x</code> we can simply apply it to the opposite values in either position:</p>
<pre><code>not = λ x . if x false true</code></pre>
<p><code>not x</code> will therefore return <code>false</code> if <code>x</code> is <code>true</code>, and <code>true</code> if <code>x</code> is <code>false</code>; equationally:</p>
<pre><code>not true  = false
not false = true</code></pre>
<p>Which is precisely the meaning we intended <code>not</code> to have.</p>
<aside>
<p>Note that this is not the only way that we could have implemented <code>not</code>.</p>
<p><code>not</code>’s type is <code>Bool -&gt; Bool</code>, which is equivalent to <code>(∀ a . a -&gt; a -&gt; a) -&gt; ∀ a . a -&gt; a -&gt; a</code> Thus, we could also define <code>not</code> by taking the extra arguments that the <em>result</em> <code>Bool</code> will be applied to, and using them directly, though in the opposite order:</p>
<pre><code>not = λ x then else . if x else then</code></pre>
<p>Or equivalently, but perhaps <em>slightly</em> more familiar:</p>
<pre><code>not = λ x . λ then else . if x else then</code></pre>
<p>This style of definition can be surprising if you’re not used to so-called “curried functions” as commonly used in e.g. Haskell, but it’s operationally equivalent to the definition developed above. As an exercise, try to work out why that equivalence holds.</p>
</aside>
<p><code>or</code> and <code>and</code> are closely related to one another, so we’ll define them simultaneously. Both take two <code>Bool</code>s and return a <code>Bool</code>:</p>
<pre><code>or, and : Bool -&gt; Bool -&gt; Bool
or  = λ x y . ?
and = λ x y . ?</code></pre>
<p>As with <code>not</code>, all we can do with <code>Bool</code>s is branch:</p>
<pre><code>or  = λ x y . if x ? ?
and = λ x y . if x ? ?</code></pre>
<p>For <code>or</code>, if <code>x</code> is <code>true</code>, we can return <code>true</code> immediately (“short-circuiting”). For <code>and</code>, it’s the opposite:</p>
<pre><code>or  = λ x y . if x true ?
and = λ x y . if x ?    false</code></pre>
<p>If <code>x</code> is <code>false</code>, <code>or</code> needs to test whether <code>y</code> is <code>true</code>; likewise, if <code>x</code> is <code>true</code>, <code>and</code> needs to test whether <code>y</code> is also <code>true</code>. Once more, all we can do with <code>Bool</code>s is branch:</p>
<pre><code>or  = λ x y . if x true       (if y ? ?)
and = λ x y . if x (if y ? ?) false</code></pre>
<p>And since we must return a <code>Bool</code>, we can use <code>true</code> and <code>false</code>:</p>
<pre><code>or  = λ x y . if x true              (if y true false)
and = λ x y . if x (if y true false) false</code></pre>
<p>Pleasantly, <code>if y true false</code> (and likewise <code>y true false</code>) is operationally equivalent to <code>y</code>. Using that equivalence, we can simplify these definitions, leaving us with:</p>
<pre><code>or  = λ x y . if x true y
and = λ x y . if x y    false</code></pre>
<aside>
<p>As an exercise, define <code>xor : Bool -&gt; Bool -&gt; Bool</code>.</p>
</aside>
<h2 id="conclusion">Conclusion</h2>
<p>In this post, we’ve explored defining a ubiquitous programming language feature—booleans—using nothing more than the spartan trappings of the lambda calculus. We’ve emerged with a language which can express not merely functions and their applications, but also fundamental metaphysical concepts such as truth.</p>
<p>In the next post, we’ll look at lambda-encodings of beauty: ML/Haskell-style algebraic datatypes.</p>]]></summary>
</entry>
<entry>
    <title>Pattern matching over recursive values in Swift</title>
    <link href="https://antitypical.com/posts/2015-07-01-pattern-matching-over-recursive-values-in-swift/index.html" />
    <id>https://antitypical.com/posts/2015-07-01-pattern-matching-over-recursive-values-in-swift/index.html</id>
    <published>2015-07-01T02:29:44Z</published>
    <updated>2015-07-01T02:29:44Z</updated>
    <summary type="html"><![CDATA[<p>Swift’s value types are <em>almost</em> able to represent algebraic data types. Unfortunately, they fall short of the mark when it comes to recursion, and while they’ve announced that their solution, indirect <code>case</code>s, will ship in a later build of Swift 2, there’s still reason to want them today.</p>
<!--more-->
<p>The standard solution is to use <code>Box&lt;T&gt;</code>, a function, or some other reference type to manually force an indirection for the recursive cases:</p>
<pre class="swift"><code>enum Expression {
	case Variable(String)
	case Abstraction(String, Box&lt;Expression&gt;)
	case Application(Box&lt;Expression&gt;, Box&lt;Expression&gt;)
}</code></pre>
<p>Unfortunately, this has a few significant warts:</p>
<ul>
<li>Clients of the API have to know about <code>Box&lt;T&gt;</code>; it can’t be a private implementation detail. This can in turn lead to ambiguities if APIs aren’t using a common dependency to provide the <code>Box&lt;T&gt;</code> type. Further, they have to box and unbox the values themselves.</li>
<li>Pattern matching cannot be performed recursively in a single step.</li>
</ul>
<p>Indirect cases will (I believe) resolve both of these issues, but there’s another solution we can apply today which solves both <em>and</em> provides a significant increase in the expressiveness of the type, at the expense of introducing a (useful) intermediary type.</p>
<p>To begin with, note that in Swift 2, it’s no longer necessary to box elements of parameterized types in enum cases. This suggests a straightforward refactoring: replace <code>Expression</code>’s recursive instances with elements of a type parameter:</p>
<pre class="swift"><code>enum Expression&lt;Recur&gt; {
	case Variable(String)
	case Abstraction(String, Recur)
	case Application(Recur, Recur)
}</code></pre>
<p>Now we’ve got an <code>Expression</code> type that can be instantiated with a given type parameter to recur. But if we try to describe the type of a recursive instance of it, we immediately run into a wall:</p>
<pre class="swift"><code>let expression: Expression&lt;Expression&lt;Expression&lt;…&gt;&gt;&gt;</code></pre>
<p>It would seem we’ve simply moved the problem from the <code>case</code>s to the type, and can now see more clearly why Swift doesn’t allow <code>case</code>s to recur directly: it amounts to an infinite type. Some indirection is required, <em>somewhere</em>, and by allowing the programmer to place it (whether by explicit boxing or an <code>indirect</code> keyword), the performance implications are somewhat under their control, rather than the compiler’s.</p>
<p>We need some way to tie <code>Expression</code> into a knot (as it were), looping back around into itself, but without requiring us to write out an infinite list of nested type parameters. If we were writing a function instead of a type, we could use the <a href="https://github.com/robrix/Prelude#fix"><code>fix</code></a> function, which computes the <a href="https://en.wikipedia.org/wiki/Fixed-point_combinator#Strict_fixed_point_combinator">least fixed point</a> of a function, to lift a nonrecursive function into a recursive one:</p>
<pre class="swift"><code>let factorial = fix { recur in
    { n in n &gt; 0 ? n * recur(n - 1) : 1 }
}</code></pre>
<p>Instead of making a recursive function, we make a nonrecursive function taking a function as a parameter, and return an inner function which calls through it in order to recur. <code>fix</code> calls the outer function with a closure which calls back into <code>fix</code>, tying the knot. Is there an analogous fixed point for types? If there were, we would expect it to have the same overall shape: it would apply a type constructor like <code>Expression&lt;T&gt;</code> to a type which itself provides the connection back to <code>Expression&lt;T&gt;</code>.</p>
<p>I’ll let you in on a secret: types are functions, too. <code>Expression&lt;T&gt;</code> is actually a function, abstracted over a parameter <code>T</code> to a concrete instance of <code>Expression</code> with <code>Recur</code> instantiated to <code>T</code>. And it turns out that, like other functions, types also have fixed points.</p>
<p>In Haskell (the inevitable destination of any discussion of fixed points in programming languages), we could write this <code>Fix</code> type of a parameter type <code>f</code> like so:</p>
<div class="sourceCode" id="cb5"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb5-1"><a href="#cb5-1" aria-hidden="true"></a><span class="kw">data</span> <span class="dt">Fix</span> f <span class="ot">=</span> <span class="dt">Fix</span> (f (<span class="dt">Fix</span> f))</span></code></pre></div>
<p>This is Haskell notation approaching its densest form, so let’s compare it with how <code>fix</code> (the least fixed point of functions) is defined in Swift:</p>
<pre class="swift"><code>public func fix&lt;A, B&gt;(f: (A -&gt; B) -&gt; A -&gt; B) -&gt; A -&gt; B {
	return { f(fix(f))($0) }
}</code></pre>
<p>The <code>fix</code> function applies <code>f</code>, the function parameter passed to <code>fix</code>, to the result of applying <code>fix</code> recursively to <code>f</code> again. It wraps this up in another closure to avoid infinite looping.</p>
<p>Analogously, the <code>Fix</code> type applies <code>f</code>, the type parameter passed to <code>fix</code>, to the result of applying <code>Fix</code> recursively to <code>f</code> again. Haskell is lazily-evaluated, so it doesn’t need to wrap the lot of it up again.</p>
<p>Let’s try writing <code>Fix</code> in Swift. It only has one <code>case</code>, so it can be a struct instead of an <code>enum</code>.</p>
<pre class="swift"><code>struct Fix {}</code></pre>
<p>Now it needs to have a type parameter, <code>F</code>.</p>
<pre class="swift"><code>struct Fix&lt;F&gt; {}</code></pre>
<p>So far so good. Now we need to apply <code>F</code> to itself, recursively. But doesn’t that cause the infinite sequence of nested types again? <code>Fix&lt;F&lt;Fix&lt;F&lt;…&gt;&gt;&gt;&gt;</code> is no improvement on <code>Expression&lt;Expression&lt;Expression&lt;…&gt;&gt;&gt;</code>.</p>
<p>Fortunately, Swift allows you to refer to a type without reference to its type parameters in its body:</p>
<pre class="swift"><code>struct Fix&lt;F&gt; {
	let body: F&lt;Fix&gt;
}</code></pre>
<p>Unfortunately, while <code>Fix</code> is a complete reference inside the body of this type, Swift doesn’t know that <code>F</code> can accept type parameters, and thus rejects this. We can be sneaky and use a <code>protocol</code> with a <code>typealias</code> to work around this:</p>
<pre class="swift"><code>protocol Fixable {
	typealias Recur
}

struct Fix&lt;F: Fixable&gt; {
	let body: F
}</code></pre>
<p>But now when we add the constraint to tie <code>F</code> into a knot, we run into a new issue: <code>swiftc</code> crashes. (<a href="http://www.openradar.appspot.com/20000145">rdar://20000145</a>).</p>
<pre class="swift"><code>protocol Fixable {
	typealias Recur
}

struct Fix&lt;F: Fixable where F.Recur == Fix&gt; {
	let body: F
}
// =&gt; fish: Job 1, &#39;swift boom.swift&#39; terminated by signal SIGSEGV (Address boundary error)</code></pre>
<p>Fortunately, while Swift can’t express a <em>generic</em> <code>Fix</code> over any arbitrary fixable type, it <em>can</em> express a fixed point of <code>Expression</code> <em>specifically</em>. Let’s call this new type <code>Term</code>. Once again, it’s a <code>struct</code>, and its body holds an <code>Expression</code> instantiated to itself. This one errors out, but it’s clear we’re getting closer:</p>
<pre class="swift"><code>struct Term {
	let body: Expression&lt;Term&gt;
}
// =&gt; error: recursive value type &#39;Term&#39; is not allowed</code></pre>
<p><code>Term</code> is recursive because it holds an <code>Expression</code> which in turn holds (in some of its cases) a <code>Recur</code>, which we’ve instantiated to <code>Term</code>. We need to reintroduce an indirection via a reference type like <code>Box&lt;T&gt;</code> or a function.</p>
<p>Haven’t we just moved the problem around again? Well, sort of. Certainly we still need to box the values, but now we can do it in one and only one place—<code>Term</code>—and additionally we can make it <code>private</code>, avoiding exposing our implementation details to our consumers. Our constructor and getter can handle the boxing and unboxing for us:</p>
<pre class="swift"><code>struct Term {
	init(body: Expression&lt;Term&gt;) {
		boxedBody = Box(body)
	}

	var body: Expression&lt;Term&gt; {
		return boxedBody.value
	}

	private let boxedBody: Box&lt;Expression&lt;Term&gt;&gt;
}</code></pre>
<p>That’s a pretty decent reason to use this approach right now (if you can’t wait for indirect cases). But it only solves one of the problems we mentioned initially; we still can’t pattern match recursively. For example, if we wanted to evaluate application expressions, we would want to write something like this:</p>
<pre class="swift"><code>switch expression {
case let .Application(.Abstraction(variable, body), argument):
	// substitute argument for variable in body
default:
	// throw an error
}</code></pre>
<p>But because of the <code>Term</code> and <code>Box</code>, neither of which can be matched through, we would have to write this instead:</p>
<pre class="swift"><code>switch expression {
case let .Application(abstraction, argument):
	switch abstraction.body {
	case let .Abstraction(variable, body):
		// substitute argument for variable in body
	default:
		break
	}
	fallthrough
default:
	// throw an error
}</code></pre>
<p>If we could flatten out the type, we could pattern match. Flattening out the type would put us straight back into the infinite sequence of <code>Expression&lt;…&gt;</code>s; but maybe we can only <em>partially</em> flatten it?</p>
<p>We don’t need to pattern match against arbitrarily-nested terms for this example; we just want to match against a single nested layer. Therefore, we really only need to flatten out a single step of the recursive type. We’d need to apply this for each appearance of <code>Recur</code> in <code>Expression</code>, replacing it with <code>Expression&lt;Recur&gt;</code>.</p>
<p>Replacing each instance of a type parameter with an instance of another type parameter sounds like a job for a <code>map</code> function. In Haskell, this function is known as <code>fmap</code>, for functor map, where functors are a kind of mathematical object with some specific shape, and where map preserves this shape. For example, the <code>Array.map</code> method, given some function <code>transform</code>, produces a new array with the same number of elements and in the same order (i.e. preserving the structure of the array), but with each element replaced by applying <code>transform</code>. Array, then, is a functor; and it turns out, so is our <code>Expression</code> tree.</p>
<p>In our case, <code>map</code> should replace the <code>Recur</code> instances with the result of applying some function to them. There are no instances of <code>Recur</code> in <code>Variable</code> cases, so it should just re-wrap the variable name in the resulting type; the <code>Abstraction</code> and <code>Application</code> cases will apply <code>transform</code>:</p>
<pre class="swift"><code>enum Expression&lt;Recur&gt; {
	…
	func map&lt;Other&gt;(transform: Recur -&gt; Other) -&gt; Expression&lt;Other&gt; {
		switch self {
		case let .Variable(x):
			return .Variable(x)
		case let .Abstraction(x, body):
			return .Abstraction(x, transform(body))
		case let .Application(a, b):
			return .Application(transform(a), transform(b))
		}
	}
}</code></pre>
<p>We can use this to implement <a href="http://patrickthomson.ghost.io/an-introduction-to-recursion-schemes/">recursion schemes</a>, improving our confidence in recursive functions over the type, but for now we’ll limit ourselves to enabling pattern matching. Given an <code>Expression&lt;Recur&gt;</code>, we want to replace each <code>Recur</code> with its recursive instantiation, <code>Expression&lt;Recur&gt;</code>. Otherwise put, we need a function of type <code>Expression&lt;Recur&gt; -&gt; Expression&lt;Expression&lt;Recur&gt;&gt;</code>. Let’s implement this as a method, and call it destructure (since it decomposes the structure of the type):</p>
<pre class="swift"><code>enum Expression&lt;Recur&gt; {
	…
	func destructure() -&gt; Expression&lt;Expression&lt;Recur&gt;&gt; {
		return map {
			// what do we do here?
		}
	}
}</code></pre>
<p>…but we can’t! To implement a function of type <code>Expression&lt;Recur&gt; -&gt; Expression&lt;Expression&lt;Recur&gt;&gt;</code> using <code>map</code>, we’d need a function of type <code>Recur -&gt; Expression&lt;Recur&gt;</code> to pass to it. There is no useful function that can do this; without knowing a <em>specific</em> (and actually recursive) type for <code>Recur</code>, we have no way to recover the <code>Expression&lt;Recur&gt;</code> that we want to return.</p>
<p>Instead, let’s use a constrained extension to limit ourselves to <code>Expression&lt;Term&gt;</code>. Unfortunately it’s not <em>quite</em> that simple, because Swift, for reasons beyond my knowledge (<a href="http://www.openradar.appspot.com/21512469">rdar://21512469</a>), forbids the obvious thing:</p>
<pre class="swift"><code>extension Expression where Recur == Term { … }
// =&gt; error: same-type requirement makes generic parameter &#39;Recur&#39; non-generic</code></pre>
<p>We’ll work around this using a protocol, <code>FixpointType</code>:</p>
<pre class="swift"><code>protocol FixpointType {
	typealias Fixed
}

extension Term: FixpointType {
	typealias Fixed = Expression&lt;Term&gt;
}</code></pre>
<p>Now we can constrain the extension to <code>FixpointType</code> like we want:</p>
<pre class="swift"><code>extension Expression where Recur : FixpointType, Recur.Fixed == Expression&lt;Recur&gt; {
	func destructure() -&gt; Expression&lt;Expression&lt;Recur&gt;&gt; {
		return map {
			// what do we do here?
		}
	}
}</code></pre>
<p>There are two problems remaining with this implementation:</p>
<ol type="1">
<li>We still don’t have a way to get an <code>Expression&lt;Recur&gt;</code> from a <code>Recur</code>.</li>
<li><code>swiftc</code> crashes. (<a href="http://openradar.appspot.com/21328632">rdar://21328632</a>)</li>
</ol>
<p>Fortunately, we can resolve the former by adding a property to the protocol:</p>
<pre class="swift"><code>protocol FixpointType {
	typealias Fixed
	var body: Fixed { get }
}</code></pre>
<p>With that out of the way, we can work around the crash by loosening the constraints slightly; we don’t actually require that <code>Recur.Fixed</code> be recursive; we just need to be able to name it. Now we can give the return type of <code>destructure</code> as <code>Expression&lt;Recur.Fixed&gt;</code>, and implement it in the obvious way, mapping each term to its body:</p>
<pre class="swift"><code>extension Expression where Recur : FixpointType {
	func destructure() -&gt; Expression&lt;Recur.Fixed&gt; {
		return map { term in term.body }
	}
}</code></pre>
<p>Now we can use <code>destructure</code> to implement evaluation of well-formed <code>.Application</code> expressions, using exactly the pattern matching we wanted in the first place:</p>
<pre class="swift"><code>switch expression.destructure() {
case let .Application(.Abstraction(variable, body), argument):
	// substitute argument for variable in body
default:
	// throw an error
}</code></pre>
<p><a href="https://gist.github.com/robrix/4696ec3c117aac97ef0b">Full code listing</a>.</p>]]></summary>
</entry>
<entry>
    <title>On the Order of Neptune</title>
    <link href="https://antitypical.com/posts/2014-04-20-on-the-order-of-neptune/index.html" />
    <id>https://antitypical.com/posts/2014-04-20-on-the-order-of-neptune/index.html</id>
    <published>2014-04-20T04:20:00Z</published>
    <updated>2014-04-20T04:20:00Z</updated>
    <summary type="html"><![CDATA[<p><a href="http://en.wikipedia.org/wiki/Inscribed_figure">Inscribe</a> the <a href="http://en.wikipedia.org/wiki/Neptune#Orbit_and_rotation">orbit of Neptune</a> in a square.</p>
<!--more-->
<p>Now, take a pair of integers as <em>x</em> and <em>y</em> coordinates across this square. Their size in bits determines the resolution at which they can measure this square.</p>
<p>An integer of <em>n</em> bits can hold any of 2<em>ⁿ</em> distinct values. 32-bit integers, therefore, would divide the square into a grid of 2³² points.</p>
<p>At 32 bits of resolution, adjacent coordinates, e.g. …<code>0101</code> and …<code>0110</code>, are about a kilometre apart on our square.</p>
<p>If we double the size of our integers, we now divide the square into a grid of 2⁶⁴ points.</p>
<p>At 64 bits of resolution, still covering the <em>entire span of the orbit of Neptune</em>, adjacent coordinates are about 0.24µm apart, or about 1% of the width of <a href="http://hypertextbook.com/facts/1999/BrianLey.shtml">an average human hair</a>.</p>
<p>And famously, populating a 128-bit address space would require us to <a href="https://blogs.oracle.com/bonwick/entry/128_bit_storage_are_you">boil the oceans</a>.</p>]]></summary>
</entry>

</feed>
